<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; style-src 'self' https://fonts.googleapis.com 'unsafe-inline'; font-src https://fonts.gstatic.com; connect-src 'self' https://maze2-36f1f-default-rtdb.firebaseio.com; img-src 'self' data:; media-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none'">
    <!-- PWA & Mobile App Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GameyBoy">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6b6b7b" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#5a5a6a" media="(prefers-color-scheme: dark)">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <!-- Prevent text size adjustment on orientation change -->
    <meta name="HandheldFriendly" content="true">
    <title>Maze Runner - GameyBoy</title>
    <!-- Preload critical font -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" as="style">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4.2.0/dist/index.global.js" integrity="sha384-bNsax73PC6D4xYSie+xNpMGj6fF6bgWPHOoXMLpYtrI6eZPTxNAJHmkPQAnr8atN" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Dynamic viewport height - set by JS for iOS Safari compatibility */
            --vh: 1vh;
            --app-height: 100dvh;
            --app-width: 100vw;
            /* Safe area insets - set by JS */
            --safe-area-top: 0px;
            --safe-area-bottom: 0px;
            --safe-area-left: 0px;
            --safe-area-right: 0px;
        }

        /* Base interaction defaults */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        html {
            /* Prevent iOS text size adjust */
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
            /* Smooth scrolling where allowed */
            scroll-behavior: smooth;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            /* Allow touch but prevent zoom/scroll behaviors */
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            height: 100%;
            height: var(--app-height);
            min-height: var(--app-height);
            width: 100%;
            width: var(--app-width);
            min-width: var(--app-width);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            /* Prevent pull-to-refresh and overscroll */
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            /* GPU acceleration */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Loading overlay - shown until fonts are ready */
        .app-loading {
            position: fixed;
            inset: 0;
            background: linear-gradient(145deg, #8b8b9b 0%, #6b6b7b 50%, #5a5a6a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s ease-out;
        }

        .app-loading.loaded {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: #2a2a3a;
            animation: pulse-load 1s ease-in-out infinite;
        }

        @keyframes pulse-load {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Ensure hidden class works (Tailwind fallback) */
        .hidden {
            display: none !important;
        }

        /* Screen buttons (BACK, START, PLAY, etc.) */
        .screen-content button {
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            cursor: pointer;
        }

        /* Pixel font base */
        .pixel-font {
            font-family: 'Press Start 2P', monospace;
            letter-spacing: -1px;
        }

        .character-logo {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(4px, 0.9vw, 5px);
            line-height: 1.05;
            letter-spacing: 0;
            display: inline-block;
            text-align: left;
            min-height: 26px;
        }

        .character-logo-row {
            display: block;
            white-space: pre;
        }

        /* GameyBoy Device Styles */
        .gameboy-device {
            background: linear-gradient(145deg, #8b8b9b 0%, #6b6b7b 50%, #5a5a6a 100%);
            border-radius: 20px 20px 60px 60px;
            padding: 20px;
            box-shadow:
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -2px 4px rgba(0,0,0,0.3),
                0 10px 30px rgba(0,0,0,0.5),
                0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }

        .gameboy-device::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 20px;
            right: 20px;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            border-radius: 2px;
        }

        /* Screen bezel */
        .screen-bezel {
            background: linear-gradient(145deg, #2d2d3d 0%, #1a1a2a 100%);
            border-radius: 8px;
            padding: 12px;
            box-shadow:
                inset 0 4px 8px rgba(0,0,0,0.5),
                inset 0 -2px 4px rgba(255,255,255,0.1);
            position: relative;
            z-index: 2;
        }

        .screen-bezel::before {
            content: 'DOT MATRIX WITH STEREO SOUND';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(8px, 1.8vw, 9px);
            color: #4a4a5a;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        /* LCD Screen effect */
        .lcd-screen {
            background: #9bbc0f;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }

        .lcd-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.03) 2px,
                rgba(0,0,0,0.03) 4px
            );
            pointer-events: none;
            z-index: 10;
        }

        .lcd-screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 11;
        }

        /* Screen content colors - Game Boy palette */
        .lcd-screen {
            --gb-darkest: #0f380f;
            --gb-dark: #306230;
            --gb-light: #8bac0f;
            --gb-lightest: #9bbc0f;
        }

        /* Brand text */
        .brand-text {
            color: #3a3a4a;
            font-size: 16px;
            font-style: italic;
            font-weight: bold;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
            font-family: 'Arial Black', sans-serif;
            letter-spacing: 2px;
        }

        .brand-text span {
            color: #2a5298;
        }

        /* Power LED */
        .power-led {
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        .power-led.on {
            background: #ff3333;
            box-shadow: 0 0 8px #ff3333, inset 0 -1px 2px rgba(0,0,0,0.3);
            animation: led-pulse 2s ease-in-out infinite;
        }

        @keyframes led-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* D-Pad styles */
        .dpad-container {
            width: 100px;
            height: 100px;
            position: relative;
        }

        .dpad {
            position: absolute;
            background: #2a2a3a;
            box-shadow:
                inset 0 -3px 6px rgba(0,0,0,0.4),
                0 2px 4px rgba(0,0,0,0.3);
        }

        .dpad-vertical {
            width: 34px;
            height: 100px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 4px;
        }

        .dpad-horizontal {
            width: 100px;
            height: 34px;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 4px;
        }

        .dpad-center {
            position: absolute;
            width: 34px;
            height: 34px;
            background: #3a3a4a;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        /* D-pad touch overlay — single large touch target */
        #dpad-touch-overlay {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            z-index: 5;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            cursor: pointer;
        }

        /* Directional highlight feedback */
        .dpad-container.dir-up .dpad-vertical { box-shadow: inset 0 12px 12px -6px rgba(255,255,255,0.25); }
        .dpad-container.dir-down .dpad-vertical { box-shadow: inset 0 -12px 12px -6px rgba(255,255,255,0.25); }
        .dpad-container.dir-left .dpad-horizontal { box-shadow: inset 12px 0 12px -6px rgba(255,255,255,0.25); }
        .dpad-container.dir-right .dpad-horizontal { box-shadow: inset -12px 0 12px -6px rgba(255,255,255,0.25); }

        /* Action buttons */
        .action-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #8b2252 0%, #6b1242 100%);
            border: none;
            box-shadow:
                inset 0 2px 4px rgba(255,255,255,0.2),
                inset 0 -2px 4px rgba(0,0,0,0.3),
                0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #2a2a3a;
            text-shadow: 0 1px 0 rgba(255,255,255,0.2);
            /* Ensure touch events work */
            touch-action: manipulation;
        }

        .action-btn:active,
        .action-btn.pressed {
            box-shadow:
                inset 0 2px 4px rgba(0,0,0,0.3),
                0 2px 4px rgba(0,0,0,0.2);
            transform: translateY(2px);
        }

        .action-btn-b {
            background: linear-gradient(145deg, #8b2252 0%, #6b1242 100%);
        }

        .action-btn-a {
            background: linear-gradient(145deg, #8b2252 0%, #6b1242 100%);
        }

        /* Start/Select buttons */
        .menu-btn {
            width: 40px;
            height: 12px;
            background: #4a4a5a;
            border: none;
            border-radius: 6px;
            box-shadow:
                inset 0 2px 3px rgba(0,0,0,0.4),
                0 1px 2px rgba(0,0,0,0.2);
            cursor: pointer;
            transform: rotate(-25deg);
            /* Ensure touch events work */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .menu-btn:active,
        .menu-btn.pressed {
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.5);
            background: #3a3a4a;
        }

        /* Speaker grille */
        .speaker-grille {
            display: flex;
            flex-direction: column;
            gap: 3px;
            transform: rotate(-25deg);
        }

        .speaker-line {
            width: 40px;
            height: 4px;
            background: #3a3a4a;
            border-radius: 2px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Screen content styling */
        .screen-content {
            color: #0f380f;
            position: relative;
            z-index: 5;
        }

        .screen-content h1, .screen-content h2, .screen-content h3 {
            color: #0f380f;
            text-shadow: 2px 2px 0 #306230;
        }

        .screen-content button {
            background: #306230;
            color: #9bbc0f;
            border: 3px solid #0f380f;
            font-family: 'Press Start 2P', monospace;
            cursor: pointer;
            transition: all 0.1s;
        }

        /* Only apply hover states on devices that support true hover (not touch) */
        @media (hover: hover) and (pointer: fine) {
            .screen-content button:hover {
                background: #0f380f;
                color: #9bbc0f;
            }
        }

        .screen-content button:active,
        .screen-content button.pressed {
            transform: scale(0.95);
            background: #0f380f;
            color: #9bbc0f;
        }

        .screen-content input {
            background: #8bac0f;
            color: #0f380f;
            border: 3px solid #0f380f;
            font-family: 'Press Start 2P', monospace;
        }

        .screen-content input:focus {
            outline: none;
            background: #9bbc0f;
        }

        /* Retro selection cursor */
        .menu-cursor::before {
            content: '►';
            margin-right: 8px;
        }

        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        .shake { animation: shake 0.3s ease-in-out; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .blink {
            animation: blink 1s step-end infinite;
        }

        /* Boot screen */
        @keyframes boot-fade-in {
            0% { opacity: 0; transform: translateY(6px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        #boot-screen {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .boot-credit {
            opacity: 0;
            animation: boot-fade-in 0.6s ease-out forwards;
        }

        .boot-credit:nth-child(1) { animation-delay: 0.3s; }
        .boot-credit:nth-child(2) { animation-delay: 1.1s; }
        .boot-credit:nth-child(3) { animation-delay: 1.9s; }

        #game-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -webkit-image-rendering: pixelated;
            /* GPU acceleration for smooth rendering */
            will-change: contents;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            /* Prevent any touch interactions on canvas */
            touch-action: none;
            pointer-events: none;
        }

        /* Wrapper for canvas to handle touch */
        .canvas-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        /* Mobile fullscreen - phone becomes the Game Boy */
        @media (max-width: 640px) {
            html, body {
                background: linear-gradient(145deg, #8b8b9b 0%, #6b6b7b 50%, #5a5a6a 100%);
                overflow: hidden;
                position: fixed;
                width: var(--app-width);
                min-width: var(--app-width);
                height: var(--app-height);
                min-height: var(--app-height);
                /* Prevent iOS rubber-banding */
                overscroll-behavior: none;
            }

            /* Remove outer body padding on mobile */
            body.min-h-screen {
                padding: 0 !important;
            }

            .gameboy-device {
                position: fixed !important;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                width: var(--app-width) !important;
                min-width: var(--app-width) !important;
                height: var(--app-height) !important;
                min-height: var(--app-height) !important;
                max-width: none !important;
                border-radius: 0 !important;
                padding: 8px;
                display: flex;
                flex-direction: column;
                box-shadow: none !important;
                margin: 0 !important;
            }

            .gameboy-device::before {
                display: none;
            }

            /* Brand area - compact but visible */
            .brand-area {
                flex-shrink: 0;
                padding: 6px 12px;
                min-height: 32px;
            }

            .brand-text {
                font-size: 14px;
            }

            /* Screen bezel - takes available space dynamically */
            .screen-bezel {
                flex: 1 1 auto;
                display: flex;
                flex-direction: column;
                padding: 8px;
                margin-bottom: 8px;
                min-height: 0;
                overflow: hidden;
            }

            .screen-bezel::before {
                display: none;
            }

            .lcd-screen {
                flex: 1 1 auto;
                display: flex;
                flex-direction: column;
                min-height: 0;
                overflow: hidden;
            }

            .screen-content {
                flex: 1 1 auto;
                display: flex;
                flex-direction: column;
                padding: 6px !important;
                min-height: 0 !important;
                overflow: hidden;
                height: auto !important;
            }

            .screen-content > div {
                flex: 1 1 auto;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }

            #game-screen {
                flex: 1 1 auto !important;
                justify-content: center !important;
                align-items: center !important;
                overflow: hidden;
            }

            #game-screen canvas {
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
                display: block;
            }

            /* Menu screens - scrollable if needed */
            #name-screen, #menu-screen {
                overflow-y: auto;
                overflow-x: hidden;
                justify-content: flex-start !important;
                padding-top: 8px;
                -webkit-overflow-scrolling: touch;
            }

            .screen-content {
                font-size: 8px;
            }

            /* Controls area - fixed size at bottom */
            .controls-area {
                flex: 0 0 auto;
                padding: 8px 16px 12px 16px;
                min-height: 160px;
                max-height: 200px;
                /* Ensure touch events work on controls */
                touch-action: manipulation;
                overflow: hidden;
            }

            .desktop-only { display: none !important; }

            /* Responsive D-pad sizing based on screen width */
            .dpad-container {
                width: min(110px, 28vw);
                height: min(110px, 28vw);
            }

            .dpad-vertical {
                width: min(38px, 9.5vw);
                height: min(110px, 28vw);
            }

            .dpad-horizontal {
                width: min(110px, 28vw);
                height: min(38px, 9.5vw);
            }

            .dpad-center {
                width: min(38px, 9.5vw);
                height: min(38px, 9.5vw);
            }

            /* Responsive action buttons */
            .action-btn {
                width: min(52px, 14vw);
                height: min(52px, 14vw);
                font-size: min(12px, 3vw);
            }

            /* Responsive menu buttons */
            .menu-btn {
                width: min(50px, 12vw);
                height: min(14px, 3.5vw);
            }

            .menu-btn-label {
                font-size: min(7px, 1.8vw) !important;
            }

            /* Speaker smaller on mobile */
            .speaker-grille {
                transform: rotate(-25deg) scale(0.7);
            }

            /* Safe area for notched phones (iPhone X and later) */
            @supports (padding-top: env(safe-area-inset-top)) {
                .gameboy-device {
                    padding-top: max(8px, env(safe-area-inset-top));
                    padding-bottom: max(12px, env(safe-area-inset-bottom));
                    padding-left: max(8px, env(safe-area-inset-left));
                    padding-right: max(8px, env(safe-area-inset-right));
                }

                .controls-area {
                    padding-bottom: max(12px, calc(env(safe-area-inset-bottom) + 8px));
                }
            }
        }

        /* Small mobile screens (iPhone SE, older iPhones) */
        @media (max-width: 640px) and (max-height: 700px) {
            .brand-area {
                padding: 4px 8px;
                min-height: 28px;
            }

            .brand-text {
                font-size: 12px;
            }

            .screen-bezel {
                padding: 6px;
                margin-bottom: 6px;
            }

            .controls-area {
                min-height: 140px;
                max-height: 160px;
                padding: 6px 12px 10px 12px;
            }

            .dpad-container {
                width: min(90px, 26vw);
                height: min(90px, 26vw);
            }

            .dpad-vertical {
                width: min(32px, 9vw);
                height: min(90px, 26vw);
            }

            .dpad-horizontal {
                width: min(90px, 26vw);
                height: min(32px, 9vw);
            }

            .dpad-center {
                width: min(32px, 9vw);
                height: min(32px, 9vw);
            }

            .action-btn {
                width: min(44px, 12vw);
                height: min(44px, 12vw);
                font-size: min(10px, 2.8vw);
            }
        }

        /* Larger mobile screens (iPhone Pro Max, Plus models) */
        @media (max-width: 640px) and (min-height: 800px) {
            .controls-area {
                min-height: 180px;
                max-height: 220px;
            }

            .dpad-container {
                width: 120px;
                height: 120px;
            }

            .dpad-vertical {
                width: 42px;
                height: 120px;
            }

            .dpad-horizontal {
                width: 120px;
                height: 42px;
            }

            .dpad-center {
                width: 42px;
                height: 42px;
            }

            .action-btn {
                width: 56px;
                height: 56px;
                font-size: 14px;
            }
        }

        /* ===== MOBILE VIEWPORT HEIGHT-BASED OPTIMIZATIONS ===== */
        /* Using viewport height ranges instead of deprecated device-width queries */

        /* Very tall mobile screens (iPhone Pro Max, Plus models) - more space for controls */
        @media (max-width: 640px) and (min-height: 850px) {
            .controls-area {
                min-height: 190px;
                max-height: 230px;
            }
            .dpad-container {
                width: 125px;
                height: 125px;
            }
            .dpad-vertical {
                width: 44px;
                height: 125px;
            }
            .dpad-horizontal {
                width: 125px;
                height: 44px;
            }
            .dpad-center {
                width: 44px;
                height: 44px;
            }
            .action-btn {
                width: 58px;
                height: 58px;
                font-size: 15px;
            }
        }

        /* Extra tall screens (newer Pro Max models) */
        @media (max-width: 640px) and (min-height: 920px) {
            .controls-area {
                min-height: 200px;
                max-height: 240px;
            }
            .dpad-container {
                width: 130px;
                height: 130px;
            }
            .dpad-vertical {
                width: 46px;
                height: 130px;
            }
            .dpad-horizontal {
                width: 130px;
                height: 46px;
            }
            .dpad-center {
                width: 46px;
                height: 46px;
            }
            .action-btn {
                width: 60px;
                height: 60px;
                font-size: 16px;
            }
        }

        /* Landscape mobile */
        @media (max-width: 900px) and (orientation: landscape) and (max-height: 500px) {
            html, body {
                height: 100%;
                height: var(--app-height);
            }

            .gameboy-device {
                flex-direction: row !important;
                padding: 6px !important;
                height: var(--app-height) !important;
            }

            .brand-area {
                display: none !important;
            }

            .screen-bezel {
                flex: 1 1 auto;
                margin-bottom: 0 !important;
                margin-right: 6px;
                max-width: calc(100% - 180px);
            }

            .controls-area {
                width: 170px;
                min-width: 150px;
                min-height: auto !important;
                max-height: none !important;
                flex-direction: column;
                justify-content: space-around;
                align-items: center;
                padding: 6px !important;
            }

            .controls-area > div {
                flex-direction: column !important;
                gap: 8px !important;
            }

            .center-controls {
                flex-direction: row !important;
                order: 2;
            }

            .dpad-container {
                order: 1;
                width: min(80px, 18vh) !important;
                height: min(80px, 18vh) !important;
            }

            .dpad-vertical {
                width: min(28px, 6vh) !important;
                height: min(80px, 18vh) !important;
            }

            .dpad-horizontal {
                width: min(80px, 18vh) !important;
                height: min(28px, 6vh) !important;
            }

            .dpad-center {
                width: min(28px, 6vh) !important;
                height: min(28px, 6vh) !important;
            }

            .action-buttons {
                order: 3;
            }

            .action-btn {
                width: min(40px, 10vh) !important;
                height: min(40px, 10vh) !important;
                font-size: min(10px, 2.5vh) !important;
            }

            .speaker-grille {
                display: none !important;
            }

            .menu-btn {
                width: min(36px, 9vh);
                height: min(10px, 2.5vh);
            }

            .menu-btn-label {
                font-size: min(5px, 1.3vh) !important;
            }

            /* Safe area in landscape */
            @supports (padding-left: env(safe-area-inset-left)) {
                .gameboy-device {
                    padding-left: max(6px, env(safe-area-inset-left));
                    padding-right: max(6px, env(safe-area-inset-right));
                }
            }
        }

        @media (min-width: 641px) {
            .mobile-only { display: none !important; }
        }

        /* Mobile control buttons - industry grade touch handling */
        .mobile-btn {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
            /* Prevent text selection on long press */
            -webkit-user-select: none;
            /* GPU acceleration for smooth animations */
            will-change: transform;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            /* Smooth transition for press feedback */
            transition: transform 0.05s ease-out, box-shadow 0.05s ease-out;
            /* Ensure button is above other elements for touch */
            position: relative;
            z-index: 10;
        }

        .mobile-btn:active {
            transform: scale(0.92) translateZ(0);
        }

        /* Action button active states */
        .action-btn:active {
            transform: scale(0.92) translateY(2px) translateZ(0);
            box-shadow:
                inset 0 3px 6px rgba(0,0,0,0.4),
                0 1px 2px rgba(0,0,0,0.2) !important;
        }

        /* Menu button active states */
        .menu-btn:active {
            transform: rotate(-25deg) scale(0.95) translateZ(0);
            box-shadow: inset 0 4px 6px rgba(0,0,0,0.6) !important;
        }

        /* Allow text input selection */
        input[type="text"] {
            -webkit-user-select: text;
            user-select: text;
            touch-action: manipulation;
        }

        /* Leaderboard scrollbar - retro style */
        #leaderboard-list::-webkit-scrollbar {
            width: 8px;
        }
        #leaderboard-list::-webkit-scrollbar-track {
            background: #306230;
        }
        #leaderboard-list::-webkit-scrollbar-thumb {
            background: #0f380f;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-2 sm:p-4">
    <!-- Loading Overlay - hidden after fonts load -->
    <div id="app-loading" class="app-loading">
        <div class="loading-text">LOADING...</div>
    </div>

    <!-- Background Music -->
    <audio id="bg-music" src="playdate.mp3" loop preload="auto"></audio>

    <!-- GameyBoy Device Frame -->
    <div id="gameboy-container" class="gameboy-device max-w-md w-full" style="opacity: 0; transition: opacity 0.3s ease-in;">
        <!-- Brand and Power LED -->
        <div class="brand-area flex items-center justify-between mb-3 px-2">
            <div class="brand-text">Gamey<span>Boy</span></div>
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-600" style="font-family: sans-serif;">POWER</span>
                <div id="power-led" class="power-led on"></div>
            </div>
        </div>

        <!-- Screen Bezel -->
        <div class="screen-bezel sm:mb-4">
            <!-- LCD Screen -->
            <div class="lcd-screen">
                <div id="app" class="screen-content p-3 sm:p-4 relative" style="min-height: 320px;">

                    <!-- Boot Screen -->
                    <div id="boot-screen" class="flex flex-col items-center justify-center h-full" style="gap: 20px;">
                        <div class="boot-credit text-center">
                            <div class="text-xs" style="font-size: 9px; letter-spacing: 1px;">GAME BY</div>
                            <div class="text-sm" style="font-size: 11px; margin-top: 2px;">MJAMIV</div>
                        </div>
                        <div class="boot-credit text-center">
                            <div class="text-xs" style="font-size: 9px; letter-spacing: 1px;">CODE BY</div>
                            <div class="text-sm" style="font-size: 11px; margin-top: 2px;">CLAUDE-CODE</div>
                        </div>
                        <div class="boot-credit text-center">
                            <div class="text-xs" style="font-size: 9px; letter-spacing: 1px;">MUSIC BY</div>
                            <div class="text-sm" style="font-size: 11px; margin-top: 2px;">MJAMIV</div>
                        </div>
                    </div>

                    <!-- Name Entry Screen -->
                    <div id="name-screen" class="hidden flex flex-col items-center justify-center h-full">
                        <h1 class="text-sm sm:text-base mb-1 text-center leading-relaxed">MAZE</h1>
                        <h1 class="text-sm sm:text-base mb-4 text-center leading-relaxed">RUNNER</h1>
                        <div class="w-16 h-1 bg-[#0f380f] mb-4"></div>
                        <label for="player-name-input" class="text-xs mb-4 text-center">ENTER NAME</label>
                        <input type="text" id="player-name-input" maxlength="10" placeholder="PLAYER" autocomplete="nickname"
                            class="px-3 py-2 text-center text-xs mb-4 w-40 uppercase">
                        <button id="start-btn" class="px-6 py-2 text-xs">START</button>
                    </div>

                    <!-- Main Menu -->
                    <div id="menu-screen" class="hidden flex flex-col items-center h-full overflow-y-auto">
                        <h1 class="text-xs sm:text-sm mb-1 text-center">MAZE RUNNER</h1>
                        <p class="text-xs mb-3">Hi, <span id="player-name-display">PLAYER</span>!</p>

                        <div class="border-3 border-[#0f380f] p-2 sm:p-3 mb-3 w-full" style="background: #8bac0f;">
                            <h3 class="text-xs mb-2">HOW TO PLAY</h3>
                            <!-- Desktop controls -->
                            <div class="desktop-only text-xs space-y-1" style="font-size: clamp(9px, 2vw, 10px); line-height: 1.4;">
                                <div>ARROWS/WASD = MOVE</div>
                                <div>SPACE = ATTACK</div>
                                <div>E = REVEAL MAP</div>
                                <div>P/ESC = PAUSE</div>
                            </div>
                            <!-- Mobile controls -->
                            <div class="mobile-only text-xs space-y-1" style="font-size: clamp(9px, 2vw, 10px); line-height: 1.4;">
                                <div>D-PAD = MOVE</div>
                                <div>B BTN = ATTACK</div>
                                <div>A BTN = REVEAL</div>
                                <div>SELECT = PAUSE</div>
                            </div>
                            <div class="mt-2 pt-2 border-t-2 border-[#0f380f]" style="font-size: clamp(9px, 2vw, 10px);">
                                <p>F=GOAL *=GEM X=HAZARD M=ENEMY</p>
                                <p>!=SPD +=TIME S=SHLD ?=MAP</p>
                            </div>
                        </div>

                        <h3 class="text-xs mb-2">SELECT PLAYER</h3>
                        <div id="characters" class="flex gap-2 mb-3">
                            <button class="character-btn flex flex-col items-center p-2 border-3 border-[#0f380f]" style="background: #8bac0f; min-width: 50px;" data-char="W">
                                <div class="character-logo mb-1"></div>
                                <span style="font-size: clamp(8px, 1.8vw, 9px);">WIZARD</span>
                            </button>
                            <button class="character-btn flex flex-col items-center p-2 border-3 border-[#0f380f]" style="background: #8bac0f; min-width: 50px;" data-char="F">
                                <div class="character-logo mb-1"></div>
                                <span style="font-size: clamp(8px, 1.8vw, 9px);">FOX</span>
                            </button>
                            <button class="character-btn flex flex-col items-center p-2 border-3 border-[#0f380f]" style="background: #8bac0f; min-width: 50px;" data-char="R">
                                <div class="character-logo mb-1"></div>
                                <span style="font-size: clamp(8px, 1.8vw, 9px);">ROBOT</span>
                            </button>
                            <button class="character-btn flex flex-col items-center p-2 border-3 border-[#0f380f]" style="background: #8bac0f; min-width: 50px;" data-char="G">
                                <div class="character-logo mb-1"></div>
                                <span style="font-size: clamp(8px, 1.8vw, 9px);">GHOST</span>
                            </button>
                        </div>

                        <h3 class="text-xs mb-2">DIFFICULTY</h3>
                        <div id="difficulty-select" class="flex gap-2 mb-3">
                            <button class="diff-btn px-2 py-1 border-3 border-[#0f380f]" style="font-size: clamp(8px, 1.8vw, 9px); background: #8bac0f;" data-diff="easy">EASY</button>
                            <button class="diff-btn px-2 py-1 border-3 border-[#0f380f]" style="font-size: clamp(8px, 1.8vw, 9px); background: #306230; color: #9bbc0f;" data-diff="medium">MEDIUM</button>
                            <button class="diff-btn px-2 py-1 border-3 border-[#0f380f]" style="font-size: clamp(8px, 1.8vw, 9px); background: #8bac0f;" data-diff="hard">HARD</button>
                        </div>

                        <button id="play-btn" class="px-6 py-2 text-xs mb-3">► PLAY</button>

                        <p class="text-xs mb-2" style="font-size: clamp(9px, 2vw, 10px);">HIGH SCORE: <span id="high-score">0</span></p>

                        <div class="flex gap-2 flex-wrap justify-center">
                            <button id="music-toggle" class="px-3 py-1" style="font-size: clamp(9px, 2vw, 10px);">
                                <span id="music-icon">♪</span>
                                <span id="music-text">ON</span>
                            </button>
                            <button id="sfx-toggle" class="px-3 py-1" style="font-size: clamp(9px, 2vw, 10px);">
                                SFX <span id="sfx-text">ON</span>
                            </button>
                            <button id="leaderboard-btn" class="px-3 py-1" style="font-size: clamp(9px, 2vw, 10px);">
                                SCORES
                            </button>
                            <button id="stats-btn" class="px-3 py-1" style="font-size: clamp(9px, 2vw, 10px);">
                                STATS
                            </button>
                        </div>
                    </div>

                    <!-- Game Screen -->
                    <div id="game-screen" class="hidden flex flex-col items-center h-full">
                        <!-- HUD -->
                        <div class="flex justify-between items-center w-full mb-1 text-xs" style="font-size: clamp(10px, 2.2vw, 11px);">
                            <div class="flex gap-2">
                                <span id="score">SC:0000</span>
                                <span id="combo" class="hidden blink">x2!</span>
                            </div>
                            <div class="flex gap-2">
                                <span id="reveal-uses" style="font-size: clamp(9px, 2vw, 10px);">A:1</span>
                                <span id="level">LV:01</span>
                                <span id="timer">T:60</span>
                            </div>
                        </div>

                        <div class="relative">
                            <canvas id="game-canvas" class="border-3 border-[#0f380f]"></canvas>

                            <!-- Countdown Overlay -->
                            <div id="countdown" class="hidden absolute inset-0 flex items-center justify-center" style="background: rgba(155,188,15,0.9);">
                                <span class="text-4xl"></span>
                            </div>

                            <!-- Level Complete -->
                            <div id="level-complete" class="hidden absolute inset-0 flex flex-col items-center justify-center p-4" style="background: rgba(155,188,15,0.95);">
                                <h2 class="text-sm mb-2">LEVEL CLEAR!</h2>
                                <p class="text-xs mb-1">BONUS: +<span id="level-bonus">0</span></p>
                                <p class="text-xs" style="font-size: clamp(9px, 2vw, 10px);">NEXT: <span id="next-level-timer">3</span></p>
                            </div>

                            <!-- Tutorial Skip Button -->
                            <button id="tutorial-skip-btn" class="hidden absolute z-20"
                                style="bottom: 4px; right: 4px; background: #306230; color: #9bbc0f;
                                border: 2px solid #0f380f; font-family: 'Press Start 2P', monospace;
                                font-size: clamp(9px, 2vw, 10px); padding: 3px 8px; cursor: pointer; animation: pulse 2s ease-in-out infinite; opacity: 0.85;">
                                SKIP ►
                            </button>
                        </div>

                        <div class="mt-1">
                            <div id="powerup-display" class="flex gap-2 justify-center">
                                <span id="speed-indicator" class="hidden text-xs blink" style="font-size: clamp(9px, 2vw, 10px);">!SPEED!</span>
                                <span id="shield-indicator" class="hidden text-xs blink" style="font-size: clamp(9px, 2vw, 10px);">SHIELD</span>
                                <span id="magnet-indicator" class="hidden text-xs blink" style="font-size: clamp(9px, 2vw, 10px);">MAGNET</span>
                                <span id="freeze-indicator" class="hidden text-xs blink" style="font-size: clamp(9px, 2vw, 10px);">FREEZE</span>
                            </div>
                        </div>
                    </div>

                    <!-- Pause Overlay -->
                    <div id="pause-overlay" class="hidden absolute inset-0 flex flex-col items-center justify-center z-10 p-4" style="background: #9bbc0f;">
                        <h2 class="text-base mb-6">PAUSED</h2>
                        <button id="resume-btn" class="px-6 py-2 text-xs mb-3">► RESUME</button>
                        <button id="quit-btn" class="px-6 py-2 text-xs">QUIT</button>
                    </div>

                    <!-- Game Over -->
                    <div id="game-over" class="hidden absolute inset-0 flex flex-col items-center justify-center z-10 p-4" style="background: #9bbc0f;">
                        <h2 id="game-over-title" class="text-sm mb-4">GAME OVER</h2>
                        <p class="text-xs mb-2">SCORE: <span id="final-score">0</span></p>
                        <p class="text-xs mb-2" style="font-size: clamp(9px, 2vw, 10px);">LEVEL: <span id="final-level">1</span></p>
                        <p id="new-high-score" class="hidden text-xs mb-3 blink">*NEW RECORD*</p>
                        <div class="flex flex-col gap-2">
                            <button id="play-again-btn" class="px-6 py-2 text-xs">► RETRY</button>
                            <button id="menu-btn" class="px-6 py-2 text-xs">MENU</button>
                        </div>
                        <button id="gameover-leaderboard-btn" class="mt-3 px-4 py-1" style="font-size: clamp(9px, 2vw, 10px);">SCORES</button>
                    </div>

                    <!-- Leaderboard Overlay -->
                    <div id="leaderboard-overlay" class="hidden absolute inset-0 flex flex-col items-center z-20 p-3" style="background: #9bbc0f;">
                        <div class="flex items-center gap-2 mb-3">
                            <h2 class="text-xs">HIGH SCORES</h2>
                            <span id="leaderboard-badge" style="font-size: clamp(8px, 1.8vw, 9px); color: #9bbc0f; background: #0f380f; padding: 1px 4px; border-radius: 2px;">LOCAL</span>
                        </div>
                        <div id="leaderboard-list" class="w-full flex-1 overflow-y-auto mb-3 border-3 border-[#0f380f] p-2" style="background: #8bac0f; max-height: 200px;">
                            <!-- Leaderboard entries will be inserted here -->
                        </div>
                        <button id="close-leaderboard-btn" class="px-6 py-2 text-xs">BACK</button>
                    </div>

                    <!-- Stats Overlay -->
                    <div id="stats-overlay" class="hidden absolute inset-0 flex flex-col items-center z-20 p-3" style="background: #9bbc0f;">
                        <h2 class="text-xs mb-3">STATISTICS</h2>
                        <div id="stats-list" class="w-full flex-1 overflow-y-auto mb-3 border-3 border-[#0f380f] p-2" style="background: #8bac0f; max-height: 200px;">
                        </div>
                        <button id="close-stats-btn" class="px-6 py-2 text-xs">BACK</button>
                    </div>

                </div>
            </div>
        </div>

        <!-- Physical Controls Area -->
        <div class="controls-area flex justify-between items-start sm:mt-4 px-2">
            <!-- D-Pad (swipe-based touch control) -->
            <div class="dpad-container" id="dpad-swipe-area" aria-label="Directional pad">
                <div class="dpad dpad-vertical"></div>
                <div class="dpad dpad-horizontal"></div>
                <div class="dpad-center" id="dpad-center-dot"></div>
                <!-- Single touch overlay covering entire D-pad -->
                <div id="dpad-touch-overlay"></div>
            </div>

            <!-- Center: Start/Select -->
            <div class="center-controls flex flex-col items-center justify-center gap-2 sm:gap-4 pt-4 sm:pt-8">
                <div class="flex gap-3 sm:gap-4">
                    <div class="flex flex-col items-center gap-1">
                        <button id="select-btn" class="menu-btn mobile-btn" aria-label="Select"></button>
                        <span class="menu-btn-label text-xs text-gray-600" style="font-family: sans-serif; font-size: clamp(9px, 2vw, 10px);">SELECT</span>
                    </div>
                    <div class="flex flex-col items-center gap-1">
                        <button id="start-game-btn" class="menu-btn mobile-btn" aria-label="Start"></button>
                        <span class="menu-btn-label text-xs text-gray-600" style="font-family: sans-serif; font-size: clamp(9px, 2vw, 10px);">START</span>
                    </div>
                </div>
                <!-- Speaker Grille -->
                <div class="speaker-grille mt-1 sm:mt-2">
                    <div class="speaker-line"></div>
                    <div class="speaker-line"></div>
                    <div class="speaker-line"></div>
                    <div class="speaker-line"></div>
                    <div class="speaker-line"></div>
                    <div class="speaker-line"></div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons flex items-center gap-1 sm:gap-2 mt-3 sm:mt-4" style="transform: rotate(-25deg);">
                <div class="flex flex-col items-center gap-1">
                    <button id="btn-b" class="action-btn action-btn-b mobile-btn" aria-label="B Button">B</button>
                </div>
                <div class="flex flex-col items-center gap-1 -mt-3">
                    <button id="btn-a" class="action-btn action-btn-a mobile-btn" aria-label="A Button">A</button>
                </div>
            </div>
        </div>

        <!-- Mobile Controls (hidden by default, shown via JS) -->
        <div id="mobile-controls" class="hidden"></div>
    </div>

    <script>
        // ===== INDUSTRY-GRADE MOBILE SETUP =====

        // Viewport height fix for iOS Safari (dynamic toolbars)
        function setAppHeight() {
            const viewport = window.visualViewport;
            const viewportHeight = viewport ? viewport.height : window.innerHeight;
            const viewportWidth = viewport ? viewport.width : window.innerWidth;
            const vh = viewportHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            document.documentElement.style.setProperty('--app-height', `${viewportHeight}px`);
            document.documentElement.style.setProperty('--app-width', `${viewportWidth}px`);

            // Also set safe area insets if available
            const computedStyle = getComputedStyle(document.documentElement);
            const safeTop = computedStyle.getPropertyValue('env(safe-area-inset-top)') || '0px';
            const safeBottom = computedStyle.getPropertyValue('env(safe-area-inset-bottom)') || '0px';
            document.documentElement.style.setProperty('--safe-area-top', safeTop);
            document.documentElement.style.setProperty('--safe-area-bottom', safeBottom);
        }

        // Set initial height immediately
        setAppHeight();

        // Update on resize and orientation change
        window.addEventListener('resize', setAppHeight);
        window.addEventListener('orientationchange', () => {
            // Multiple delays to catch all layout changes
            setTimeout(setAppHeight, 100);
            setTimeout(setAppHeight, 300);
            setTimeout(setAppHeight, 500);
        });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', setAppHeight);
            window.visualViewport.addEventListener('scroll', setAppHeight);
        }

        // Update when page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                setTimeout(setAppHeight, 100);
            } else {
                // Auto-pause when tab/app is hidden
                if (typeof state !== 'undefined' && state.gameStarted && !state.gamePaused && !state.gameOver) {
                    togglePause();
                }
            }
        });

        // ===== HAPTIC FEEDBACK =====
        function hapticFeedback(type = 'light') {
            if (!navigator.vibrate) return;

            switch(type) {
                case 'light':
                    navigator.vibrate(10);
                    break;
                case 'medium':
                    navigator.vibrate(20);
                    break;
                case 'heavy':
                    navigator.vibrate(30);
                    break;
                case 'success':
                    navigator.vibrate([10, 50, 20]);
                    break;
                case 'error':
                    navigator.vibrate([30, 50, 30, 50, 30]);
                    break;
            }
        }

        // ===== SCREEN WAKE LOCK =====
        let wakeLock = null;

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        wakeLock = null;
                    });
                } catch (err) {
                    // Wake lock request failed (e.g., low battery)
                }
            }
        }

        async function releaseWakeLock() {
            if (wakeLock) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                } catch (err) {
                    // Release failed
                }
            }
        }

        // Re-request wake lock when page becomes visible
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && state && state.gameStarted && !state.gamePaused) {
                requestWakeLock();
            }
        });

        // ===== FONT LOADING & APP INITIALIZATION =====
        function hideLoadingOverlay() {
            const loadingEl = document.getElementById('app-loading');
            const containerEl = document.getElementById('gameboy-container');

            if (loadingEl) {
                loadingEl.classList.add('loaded');
                setTimeout(() => {
                    loadingEl.style.display = 'none';
                }, 300);
            }

            if (containerEl) {
                containerEl.style.opacity = '1';
            }

            startBootSequence();
        }

        function startBootSequence() {
            const bootScreen = document.getElementById('boot-screen');
            let bootTimer = setTimeout(endBootSequence, 3500);

            function skipBoot() {
                clearTimeout(bootTimer);
                bootScreen.removeEventListener('pointerdown', skipBoot);
                endBootSequence();
            }

            bootScreen.addEventListener('pointerdown', skipBoot);
        }

        let bootEnded = false;
        function endBootSequence() {
            if (bootEnded) return;
            bootEnded = true;
            const bootScreen = document.getElementById('boot-screen');
            const nameScreen = document.getElementById('name-screen');

            bootScreen.classList.add('hidden');
            nameScreen.classList.remove('hidden');

            // Play a short chime
            try {
                playTone(880, 0.08, 'square', 0.15);
                setTimeout(() => playTone(1174.66, 0.12, 'square', 0.15), 80);
            } catch (e) {}
        }

        // Wait for fonts to load before showing app
        if (document.fonts && document.fonts.ready) {
            document.fonts.ready.then(() => {
                setTimeout(hideLoadingOverlay, 100);
            });
        } else {
            // Fallback for browsers without Font Loading API
            setTimeout(hideLoadingOverlay, 500);
        }

        // ===== PREVENT UNWANTED TOUCH BEHAVIORS =====

        // Prevent pull-to-refresh only on the screen area, not controls
        document.addEventListener('touchmove', (e) => {
            const target = e.target;
            // Allow movement on buttons and scrollable areas
            if (target.closest('.mobile-btn') ||
                target.closest('.controls-area') ||
                target.closest('#menu-screen') ||
                target.closest('#leaderboard-list') ||
                target.closest('input') ||
                target.closest('button')) {
                return; // Don't prevent default for these
            }
            // Prevent pull-to-refresh on other areas
            e.preventDefault();
        }, { passive: false });

        // Prevent context menu on long press (but allow button taps)
        document.addEventListener('contextmenu', (e) => {
            if (e.target.closest('.gameboy-device') && !e.target.closest('input')) {
                e.preventDefault();
            }
        });

        // ===== RETINA DISPLAY SUPPORT =====
        function getDevicePixelRatio() {
            return Math.min(window.devicePixelRatio || 1, 3); // Cap at 3x for performance
        }

        // ===== FIREBASE CONFIG =====
        // To enable online leaderboard, create a Firebase Realtime Database and paste the URL below.
        // Example: 'https://your-project-default-rtdb.firebaseio.com'
        // Leave empty to use local-only leaderboard.
        const FIREBASE_DB_URL = 'https://maze2-36f1f-default-rtdb.firebaseio.com';
        // Do not enable direct client writes in production. Submit scores through a trusted server.
        const ALLOW_UNVERIFIED_FIREBASE_WRITES = false;

        // ===== GAME STATE =====
        const state = {
            canvas: null,
            ctx: null,
            tileSize: 32,
            mazeWidth: 15,
            mazeHeight: 15,
            maze: [],
            player: { x: 1, y: 1, targetX: 1, targetY: 1, animProgress: 1 },
            goal: { x: 13, y: 13 },
            hazards: [],
            collectibles: [],
            powerups: [],
            particles: [],

            character: '@',  // Pixel art character symbol
            characterMap: {
                'W': '@',  // Wizard
                'F': '&',  // Fox
                'R': '#',  // Robot
                'G': '%'   // Ghost
            },
            gameStarted: false,
            gamePaused: false,
            gameOver: false,

            score: 0,
            level: 1,
            timeLeft: 60,
            combo: 0,
            comboTimer: 0,
            lastCollectTime: 0,

            speedBoost: false,
            speedBoostTimer: 0,

            keysPressed: {},
            lastMoveTime: 0,
            moveDelay: 120,

            highScore: parseInt(localStorage.getItem('mazeHighScore') || '0'),
            sfxEnabled: true,
            audioCtx: null,

            bgMusic: null,
            musicEnabled: true,
            musicStarted: false,

            isMobile: false,

            playerName: '',
            leaderboard: [],

            // Difficulty
            difficulty: 'medium',

            // Enemies (patrol AI)
            enemies: [],
            enemyMoveTimer: 0,

            // Fog of war
            fogEnabled: true,
            exploredTiles: [],
            revealPulseActive: false,
            revealPulseTimer: 0,
            revealUsesLeft: 1,

            // Floating text
            floatingTexts: [],

            // Level transitions
            transitioning: false,
            transitionTiles: [],
            transitionPhase: 'none',
            transitionTimer: 0,

            // Extra powerup state
            hasShield: false,
            magnetActive: false,
            magnetTimer: 0,
            freezeActive: false,
            freezeTimer: 0,

            // Timer warning
            lastTimerTickSecond: -1,

            // Persistent stats
            stats: {
                totalGames: 0,
                totalGems: 0,
                totalHazardsDestroyed: 0,
                bestCombo: 0,
                fastestLevelClear: Infinity,
                totalTimePlayed: 0
            },

            // Game Boy color palette
            gbColors: {
                darkest: '#0f380f',
                dark: '#306230',
                light: '#8bac0f',
                lightest: '#9bbc0f'
            },

            // Tutorial state
            tutorialActive: false,
            tutorialStep: 0,
            tutorialMoveCount: 0,
            tutorialPromptTimer: 0
        };

        // ===== DIFFICULTY CONFIG =====
        const DIFFICULTY = {
            easy:   { time: 90, extraPaths: 10, hazardBase: 2, hazardMax: 5, enemyInterval: 800, enemyBase: 0, revealUses: 2 },
            medium: { time: 60, extraPaths: 5,  hazardBase: 3, hazardMax: 7, enemyInterval: 500, enemyBase: 1, revealUses: 1 },
            hard:   { time: 45, extraPaths: 2,  hazardBase: 4, hazardMax: 9, enemyInterval: 350, enemyBase: 2, revealUses: 0 }
        };

        function getMazeSize(level) {
            if (level <= 3) return { w: 15, h: 15 };
            if (level <= 6) return { w: 19, h: 19 };
            return { w: 25, h: 25 };
        }

        function toSafeInt(value, min, max, fallback) {
            const num = Number(value);
            if (!Number.isFinite(num)) return fallback;
            return Math.min(max, Math.max(min, Math.floor(num)));
        }

        function sanitizePlayerName(name, fallback = 'Player') {
            const base = String(name ?? '').trim();
            const cleaned = base.replace(/[^a-zA-Z0-9 _-]/g, '').slice(0, 10);
            return cleaned || fallback;
        }

        function normalizeLeaderboardEntry(entry) {
            if (!entry || typeof entry !== 'object') return null;
            const score = toSafeInt(entry.score, 0, 99999, 0);
            const level = toSafeInt(entry.level, 1, 999, 1);
            const dateRaw = String(entry.date ?? '').replace(/[^0-9/.\-]/g, '').slice(0, 16);

            return {
                name: sanitizePlayerName(entry.name, 'Anonymous'),
                score,
                level,
                date: dateRaw || new Date().toLocaleDateString()
            };
        }

        function normalizeStats(raw) {
            const data = raw && typeof raw === 'object' ? raw : {};
            const fastest = Number(data.fastestLevelClear);
            return {
                totalGames: toSafeInt(data.totalGames, 0, 1000000, 0),
                totalGems: toSafeInt(data.totalGems, 0, 1000000, 0),
                totalHazardsDestroyed: toSafeInt(data.totalHazardsDestroyed, 0, 1000000, 0),
                bestCombo: toSafeInt(data.bestCombo, 0, 999, 0),
                fastestLevelClear: Number.isFinite(fastest) && fastest > 0 ? Math.floor(fastest) : Infinity,
                totalTimePlayed: toSafeInt(data.totalTimePlayed, 0, 100000000, 0)
            };
        }

        // ===== LEADERBOARD =====
        function loadLeaderboard() {
            try {
                const data = localStorage.getItem('mazeLeaderboard');
                const parsed = data ? JSON.parse(data) : [];
                state.leaderboard = (Array.isArray(parsed) ? parsed : [])
                    .map(normalizeLeaderboardEntry)
                    .filter(Boolean)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 20);
            } catch (e) {
                state.leaderboard = [];
            }
        }

        function saveLeaderboard() {
            try {
                localStorage.setItem('mazeLeaderboard', JSON.stringify(state.leaderboard));
            } catch (e) {
                console.log('Could not save leaderboard');
            }
        }

        function firebaseSubmitScore(entry) {
            if (!FIREBASE_DB_URL || !ALLOW_UNVERIFIED_FIREBASE_WRITES) return;
            fetch(FIREBASE_DB_URL + '/leaderboard.json', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(entry)
            }).catch(() => {});
        }

        async function firebaseLoadLeaderboard() {
            const res = await fetch(FIREBASE_DB_URL + '/leaderboard.json');
            if (!res.ok) throw new Error('Failed to load leaderboard');
            const data = await res.json();
            if (!data || typeof data !== 'object') return [];
            return Object.values(data)
                .map(normalizeLeaderboardEntry)
                .filter(Boolean)
                .sort((a, b) => b.score - a.score)
                .slice(0, 20);
        }

        function addToLeaderboard(name, score, level) {
            const entry = normalizeLeaderboardEntry({
                name: sanitizePlayerName(name, 'Anonymous'),
                score: score,
                level: level,
                date: new Date().toLocaleDateString()
            });
            if (!entry) return;
            state.leaderboard.push(entry);
            // Sort by score descending, keep top 20
            state.leaderboard.sort((a, b) => b.score - a.score);
            state.leaderboard = state.leaderboard.slice(0, 20);
            saveLeaderboard();
            firebaseSubmitScore(entry);
        }

        function renderLeaderboard(entries) {
            const list = document.getElementById('leaderboard-list');
            const safeEntries = (Array.isArray(entries) ? entries : [])
                .map(normalizeLeaderboardEntry)
                .filter(Boolean);

            list.replaceChildren();
            if (safeEntries.length === 0) {
                const empty = document.createElement('p');
                empty.className = 'text-center py-4';
                empty.style.fontSize = 'clamp(9px, 2vw, 10px)';
                empty.style.color = '#0f380f';
                empty.textContent = 'NO SCORES YET';
                list.appendChild(empty);
                return;
            }

            const container = document.createElement('div');
            container.className = 'space-y-1';
            const currentName = sanitizePlayerName(state.playerName, '').toUpperCase();
            safeEntries.forEach((entry, index) => {
                const rank = String(index + 1).padStart(2, '0');
                const isCurrentPlayer = entry.name.toUpperCase() === currentName;
                const marker = isCurrentPlayer ? '>' : ' ';
                const scoreStr = String(entry.score).padStart(5, '0');
                const row = document.createElement('div');
                row.className = 'flex justify-between items-center';
                row.style.fontSize = 'clamp(9px, 2vw, 10px)';
                row.style.color = '#0f380f';
                row.style.fontFamily = "'Press Start 2P', monospace";

                const left = document.createElement('span');
                left.style.whiteSpace = 'pre';
                left.textContent = `${marker}${rank}.${entry.name.toUpperCase().slice(0, 8).padEnd(8, ' ')}`;

                const right = document.createElement('span');
                right.textContent = `${scoreStr} L${entry.level}`;

                row.append(left, right);
                container.appendChild(row);
            });
            list.appendChild(container);
        }

        function updateLeaderboardBadge(mode) {
            const badge = document.getElementById('leaderboard-badge');
            if (badge) badge.textContent = mode;
        }

        async function showLeaderboard() {
            const overlay = document.getElementById('leaderboard-overlay');
            overlay.classList.remove('hidden');

            if (FIREBASE_DB_URL) {
                updateLeaderboardBadge('LOADING');
                renderLeaderboard(state.leaderboard);
                try {
                    const online = await firebaseLoadLeaderboard();
                    updateLeaderboardBadge(ALLOW_UNVERIFIED_FIREBASE_WRITES ? 'ONLINE' : 'ONLINE R/O');
                    renderLeaderboard(online);
                } catch (e) {
                    updateLeaderboardBadge('LOCAL');
                    renderLeaderboard(state.leaderboard);
                }
            } else {
                updateLeaderboardBadge('LOCAL');
                renderLeaderboard(state.leaderboard);
            }
        }

        function hideLeaderboard() {
            document.getElementById('leaderboard-overlay').classList.add('hidden');
        }

        // ===== STATS =====
        function loadStats() {
            try {
                const data = localStorage.getItem('mazeStats');
                if (data) Object.assign(state.stats, normalizeStats(JSON.parse(data)));
            } catch(e) {}
        }

        function saveStats() {
            try { localStorage.setItem('mazeStats', JSON.stringify(state.stats)); } catch(e) {}
        }

        function renderStats() {
            const s = state.stats;
            const fastest = s.fastestLevelClear === Infinity ? '--' : s.fastestLevelClear + 's';
            const list = document.getElementById('stats-list');
            list.innerHTML = `
                <div class="space-y-2" style="font-size: clamp(9px, 2vw, 10px); color: #0f380f; font-family: 'Press Start 2P', monospace;">
                    <div class="flex justify-between"><span>GAMES PLAYED</span><span>${s.totalGames}</span></div>
                    <div class="flex justify-between"><span>GEMS COLLECTED</span><span>${s.totalGems}</span></div>
                    <div class="flex justify-between"><span>FOES DESTROYED</span><span>${s.totalHazardsDestroyed}</span></div>
                    <div class="flex justify-between"><span>BEST COMBO</span><span>x${s.bestCombo}</span></div>
                    <div class="flex justify-between"><span>FASTEST LEVEL</span><span>${fastest}</span></div>
                    <div class="flex justify-between"><span>TIME PLAYED</span><span>${Math.floor(s.totalTimePlayed / 60)}m${s.totalTimePlayed % 60}s</span></div>
                </div>
            `;
        }

        function showStats() {
            renderStats();
            document.getElementById('stats-overlay').classList.remove('hidden');
        }

        function hideStats() {
            document.getElementById('stats-overlay').classList.add('hidden');
        }

        // ===== AUDIO =====
        function initAudio() {
            state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Master gain → compressor → destination
            // Normalizes all SFX to peak at ~-6dBFS (industry standard)
            state.masterGain = state.audioCtx.createGain();
            state.masterGain.gain.value = 0.3;

            state.compressor = state.audioCtx.createDynamicsCompressor();
            state.compressor.threshold.value = -24;
            state.compressor.knee.value = 12;
            state.compressor.ratio.value = 8;
            state.compressor.attack.value = 0.003;
            state.compressor.release.value = 0.15;

            state.masterGain.connect(state.compressor);
            state.compressor.connect(state.audioCtx.destination);
        }

        function playTone(freq, duration, type = 'sine', volume = 0.04) {
            if (!state.sfxEnabled || !state.audioCtx) return;
            try {
                const osc = state.audioCtx.createOscillator();
                const gain = state.audioCtx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = volume;
                gain.gain.exponentialRampToValueAtTime(0.001, state.audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(state.masterGain || state.audioCtx.destination);
                osc.start();
                osc.stop(state.audioCtx.currentTime + duration);
            } catch(e) {}
        }

        // Chiptune-style sounds — volumes normalized for -6dBFS peak through master chain
        function playMove() { playTone(440, 0.03, 'square', 0.015); }
        function playCollect() {
            playTone(880, 0.08, 'square', 0.03);
            setTimeout(() => playTone(1100, 0.08, 'square', 0.03), 40);
        }
        function playDestroy() { playTone(150, 0.15, 'square', 0.03); }
        function playPowerup() {
            playTone(523, 0.08, 'square', 0.03);
            setTimeout(() => playTone(659, 0.08, 'square', 0.03), 60);
            setTimeout(() => playTone(784, 0.12, 'square', 0.03), 120);
        }
        function playWin() {
            [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'square', 0.03), i * 80));
        }
        function playLose() {
            [400, 350, 300, 250].forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'square', 0.025), i * 120));
        }

        // ===== BACKGROUND MUSIC =====
        function initBackgroundMusic() {
            state.bgMusic = document.getElementById('bg-music');
            state.bgMusic.volume = 0.12;
        }

        function startBackgroundMusic() {
            if (!state.bgMusic || !state.musicEnabled || state.musicStarted) return;
            state.bgMusic.play().then(() => {
                state.musicStarted = true;
            }).catch(e => {
                // Autoplay blocked, will try again on next interaction
                console.log('Music autoplay blocked, waiting for interaction');
            });
        }

        function toggleBackgroundMusic() {
            state.musicEnabled = !state.musicEnabled;
            localStorage.setItem('mazeMusicEnabled', state.musicEnabled.toString());
            const icon = document.getElementById('music-icon');
            const text = document.getElementById('music-text');

            if (state.musicEnabled) {
                icon.textContent = '♪';
                text.textContent = 'ON';
                if (state.musicStarted) {
                    state.bgMusic.play();
                } else {
                    startBackgroundMusic();
                }
            } else {
                icon.textContent = '♪';
                text.textContent = 'OFF';
                state.bgMusic.pause();
            }
        }

        function toggleSFX() {
            state.sfxEnabled = !state.sfxEnabled;
            localStorage.setItem('mazeSfxEnabled', state.sfxEnabled.toString());
            document.getElementById('sfx-text').textContent = state.sfxEnabled ? 'ON' : 'OFF';
        }

        function pauseBackgroundMusic() {
            if (state.bgMusic && state.musicEnabled) {
                state.bgMusic.pause();
            }
        }

        function resumeBackgroundMusic() {
            if (state.bgMusic && state.musicEnabled && state.musicStarted) {
                state.bgMusic.play();
            }
        }

        // ===== MAZE GENERATION =====
        function generateMaze() {
            const { mazeWidth, mazeHeight, level } = state;
            
            // Initialize with walls
            state.maze = Array(mazeHeight).fill().map(() => Array(mazeWidth).fill(1));
            
            // Recursive backtracking
            function carve(x, y) {
                state.maze[y][x] = 0;
                const dirs = [
                    { dx: 0, dy: -2 },
                    { dx: 0, dy: 2 },
                    { dx: -2, dy: 0 },
                    { dx: 2, dy: 0 }
                ].sort(() => Math.random() - 0.5);
                
                for (const dir of dirs) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    if (nx > 0 && nx < mazeWidth - 1 && ny > 0 && ny < mazeHeight - 1 && state.maze[ny][nx] === 1) {
                        state.maze[y + dir.dy / 2][x + dir.dx / 2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            
            carve(1, 1);
            
            // Ensure start and goal are open
            state.maze[1][1] = 0;
            state.maze[state.goal.y][state.goal.x] = 0;
            
            // Add some extra paths for easier navigation
            const diff = DIFFICULTY[state.difficulty];
            const extraPaths = diff.extraPaths;
            for (let i = 0; i < extraPaths; i++) {
                const x = Math.floor(Math.random() * (mazeWidth - 4)) + 2;
                const y = Math.floor(Math.random() * (mazeHeight - 4)) + 2;
                if (state.maze[y][x] === 1) {
                    state.maze[y][x] = 0;
                }
            }
            
            // Generate hazards
            const hazardCount = Math.min(diff.hazardBase + level, diff.hazardMax);
            state.hazards = [];
            for (let i = 0; i < hazardCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const hx = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const hy = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                    if (state.maze[hy][hx] === 0 && 
                        !(hx === 1 && hy === 1) && 
                        !(hx === state.goal.x && hy === state.goal.y) &&
                        !state.hazards.some(h => h.x === hx && h.y === hy)) {
                        state.hazards.push({ x: hx, y: hy, pulse: Math.random() * Math.PI * 2 });
                        break;
                    }
                    attempts++;
                }
            }
            
            // Generate collectibles
            const collectibleCount = 3 + Math.floor(level / 2);
            state.collectibles = [];
            for (let i = 0; i < collectibleCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const cx = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const cy = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                    if (state.maze[cy][cx] === 0 && 
                        !(cx === 1 && cy === 1) && 
                        !(cx === state.goal.x && cy === state.goal.y) &&
                        !state.hazards.some(h => h.x === cx && h.y === cy) &&
                        !state.collectibles.some(c => c.x === cx && c.y === cy)) {
                        state.collectibles.push({ x: cx, y: cy, rotation: Math.random() * Math.PI * 2 });
                        break;
                    }
                    attempts++;
                }
            }
            
            // Generate powerups (expanded variety)
            const powerupTypes = ['speed', 'time', 'shield', 'reveal', 'magnet', 'freeze'];
            const powerupCount = 1 + Math.floor(Math.random() * 2);
            state.powerups = [];
            for (let i = 0; i < powerupCount; i++) {
                let attempts = 0;
                while (attempts < 50) {
                    const px = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const py = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                    if (state.maze[py][px] === 0 &&
                        !(px === 1 && py === 1) &&
                        !(px === state.goal.x && py === state.goal.y) &&
                        !state.hazards.some(h => h.x === px && h.y === py) &&
                        !state.collectibles.some(c => c.x === px && c.y === py) &&
                        !state.powerups.some(p => p.x === px && p.y === py)) {
                        const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                        state.powerups.push({ x: px, y: py, type, pulse: 0 });
                        break;
                    }
                    attempts++;
                }
            }

            // Generate enemies (back-and-forth patrol)
            const enemyCount = Math.min(diff.enemyBase + Math.floor(level / 2), 5);
            state.enemies = [];
            for (let i = 0; i < enemyCount; i++) {
                let attempts = 0;
                while (attempts < 100) {
                    const ex = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const ey = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                    const distFromStart = Math.abs(ex - 1) + Math.abs(ey - 1);
                    if (state.maze[ey][ex] === 0 && distFromStart > 4 &&
                        !(ex === state.goal.x && ey === state.goal.y) &&
                        !state.hazards.some(h => h.x === ex && h.y === ey) &&
                        !state.enemies.some(e => e.x === ex && e.y === ey)) {
                        // Determine patrol direction: try horizontal first, then vertical
                        let dx = 1, dy = 0;
                        if (ex + 1 < mazeWidth && state.maze[ey][ex + 1] === 1 &&
                            ex - 1 >= 0 && state.maze[ey][ex - 1] === 1) {
                            dx = 0; dy = 1; // vertical patrol
                        }
                        state.enemies.push({ x: ex, y: ey, dx, dy });
                        break;
                    }
                    attempts++;
                }
            }

            // Verify maze is solvable
            if (!isSolvable()) {
                generateMaze();
            }
        }

        function isSolvable() {
            const visited = Array(state.mazeHeight).fill().map(() => Array(state.mazeWidth).fill(false));
            const queue = [{ x: 1, y: 1 }];
            visited[1][1] = true;
            
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                if (x === state.goal.x && y === state.goal.y) return true;
                
                const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < state.mazeWidth && ny >= 0 && ny < state.mazeHeight &&
                        !visited[ny][nx] && state.maze[ny][nx] === 0) {
                        visited[ny][nx] = true;
                        queue.push({ x: nx, y: ny });
                    }
                }
            }
            return false;
        }

        // ===== PARTICLES (Game Boy Style - Simple Squares) =====
        function createParticles(x, y, color, count = 6) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i;
                const speed = 1.5 + Math.random() * 2;
                state.particles.push({
                    x: x * state.tileSize + state.tileSize / 2,
                    y: y * state.tileSize + state.tileSize / 2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: state.gbColors.darkest,
                    size: 2 + Math.floor(Math.random() * 3)
                });
            }
        }

        function updateParticles() {
            state.particles = state.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15; // gravity
                p.life -= 0.05;
                p.vx *= 0.95;
                return p.life > 0;
            });
        }

        // ===== FOG OF WAR =====
        function markExplored(cx, cy, radius) {
            for (let y = 0; y < state.mazeHeight; y++) {
                for (let x = 0; x < state.mazeWidth; x++) {
                    if (Math.abs(x - cx) + Math.abs(y - cy) <= radius) {
                        state.exploredTiles[y][x] = true;
                    }
                }
            }
        }

        // ===== ENEMIES =====
        function updateEnemies(delta) {
            const diff = DIFFICULTY[state.difficulty];
            state.enemyMoveTimer += delta;
            if (state.enemyMoveTimer < diff.enemyInterval) return;
            state.enemyMoveTimer -= diff.enemyInterval;

            for (const enemy of state.enemies) {
                const nx = enemy.x + enemy.dx;
                const ny = enemy.y + enemy.dy;
                if (nx <= 0 || nx >= state.mazeWidth - 1 || ny <= 0 || ny >= state.mazeHeight - 1 ||
                    state.maze[ny][nx] === 1) {
                    enemy.dx = -enemy.dx;
                    enemy.dy = -enemy.dy;
                } else {
                    enemy.x = nx;
                    enemy.y = ny;
                }
            }

            checkEnemyCollision();
        }

        function checkEnemyCollision() {
            const px = state.player.targetX;
            const py = state.player.targetY;
            for (let i = state.enemies.length - 1; i >= 0; i--) {
                const enemy = state.enemies[i];
                if (enemy.x === px && enemy.y === py) {
                    if (state.hasShield) {
                        state.hasShield = false;
                        document.getElementById('shield-indicator').classList.add('hidden');
                        createParticles(px, py, '#AAAAFF', 10);
                        playTone(300, 0.2, 'square', 0.025);
                        state.enemies.splice(i, 1);
                        return;
                    }
                    // Penalty: lose 10 seconds, respawn at start
                    state.timeLeft = Math.max(0, state.timeLeft - 10);
                    hapticFeedback('error');
                    createParticles(px, py, '#FF0000', 12);
                    if (state.timeLeft <= 0) {
                        gameOverScreen(false);
                    } else {
                        const canvas = document.getElementById('game-canvas');
                        canvas.classList.add('shake');
                        setTimeout(() => canvas.classList.remove('shake'), 300);
                        state.player = { x: 1, y: 1, targetX: 1, targetY: 1, animProgress: 1 };
                        updateUI();
                    }
                    return;
                }
            }
        }

        // ===== FLOATING TEXT =====
        function createFloatingText(tileX, tileY, text) {
            state.floatingTexts.push({
                x: tileX * state.tileSize + state.tileSize / 2,
                y: tileY * state.tileSize,
                text: text,
                life: 1.0,
                vy: -1.5
            });
        }

        // ===== MOVEMENT =====
        function movePlayer(dx, dy) {
            if (state.transitioning) return;
            if (state.gamePaused || state.gameOver || !state.gameStarted) return;
            if (state.player.animProgress < 1) return;
            
            const now = Date.now();
            const delay = state.speedBoost ? state.moveDelay * 0.5 : state.moveDelay;
            if (now - state.lastMoveTime < delay) return;
            
            const nx = state.player.targetX + dx;
            const ny = state.player.targetY + dy;
            
            if (nx >= 0 && nx < state.mazeWidth && ny >= 0 && ny < state.mazeHeight && state.maze[ny][nx] === 0) {
                // Check hazard
                const hazardHit = state.hazards.some(h => h.x === nx && h.y === ny);
                if (hazardHit) {
                    if (state.hasShield) {
                        // Shield absorbs the hit
                        state.hasShield = false;
                        document.getElementById('shield-indicator').classList.add('hidden');
                        const hIdx = state.hazards.findIndex(h => h.x === nx && h.y === ny);
                        if (hIdx !== -1) state.hazards.splice(hIdx, 1);
                        createParticles(nx, ny, '#AAAAFF', 10);
                        playTone(300, 0.15, 'square', 0.025);
                    } else {
                        const canvas = document.getElementById('game-canvas');
                        canvas.classList.add('shake');
                        setTimeout(() => canvas.classList.remove('shake'), 300);
                        hapticFeedback('error');
                        return;
                    }
                }

                state.player.targetX = nx;
                state.player.targetY = ny;
                state.player.animProgress = 0;
                state.lastMoveTime = now;
                playMove();
                if (state.tutorialActive) checkTutorialProgress('move');

                // Update fog of war
                markExplored(nx, ny, 4);

                // Check enemy collision after move
                checkEnemyCollision();

                // Check collectibles
                const collectIdx = state.collectibles.findIndex(c => c.x === nx && c.y === ny);
                if (collectIdx !== -1) {
                    state.collectibles.splice(collectIdx, 1);

                    // Combo system
                    if (now - state.lastCollectTime < 2000) {
                        state.combo = Math.min(state.combo + 1, 5);
                    } else {
                        state.combo = 1;
                    }
                    state.lastCollectTime = now;
                    state.comboTimer = 60;

                    const points = 10 * state.combo;
                    state.score += points;
                    createParticles(nx, ny, '#FFD700', 12);
                    createFloatingText(nx, ny, `+${points}${state.combo > 1 ? ' x' + state.combo : ''}`);
                    playCollect();

                    // Stats tracking
                    state.stats.totalGems++;
                    if (state.combo > state.stats.bestCombo) state.stats.bestCombo = state.combo;
                    updateUI();
                    if (state.tutorialActive) checkTutorialProgress('collect');
                }

                // Check powerups
                const powerIdx = state.powerups.findIndex(p => p.x === nx && p.y === ny);
                if (powerIdx !== -1) {
                    const power = state.powerups[powerIdx];
                    state.powerups.splice(powerIdx, 1);

                    if (power.type === 'speed') {
                        state.speedBoost = true;
                        state.speedBoostTimer = 300;
                        document.getElementById('speed-indicator').classList.remove('hidden');
                    } else if (power.type === 'time') {
                        state.timeLeft += 10;
                    } else if (power.type === 'shield') {
                        state.hasShield = true;
                        document.getElementById('shield-indicator').classList.remove('hidden');
                    } else if (power.type === 'reveal') {
                        state.revealPulseActive = true;
                        state.revealPulseTimer = 120;
                        for (let ry = 0; ry < state.mazeHeight; ry++) {
                            for (let rx = 0; rx < state.mazeWidth; rx++) {
                                state.exploredTiles[ry][rx] = true;
                            }
                        }
                    } else if (power.type === 'magnet') {
                        state.magnetActive = true;
                        state.magnetTimer = 300;
                        document.getElementById('magnet-indicator').classList.remove('hidden');
                    } else if (power.type === 'freeze') {
                        state.freezeActive = true;
                        state.freezeTimer = 300;
                        document.getElementById('freeze-indicator').classList.remove('hidden');
                    }

                    createParticles(nx, ny, '#FFD700', 15);
                    playPowerup();
                    updateUI();
                }

                // Check goal
                if (nx === state.goal.x && ny === state.goal.y) {
                    if (state.tutorialActive) {
                        checkTutorialProgress('goal');
                    } else {
                        levelComplete();
                    }
                }
            }
        }

        function destroyHazard() {
            if (state.gamePaused || state.gameOver || !state.gameStarted) return;

            const { targetX, targetY } = state.player;
            const adjacent = [
                { x: targetX, y: targetY },
                { x: targetX + 1, y: targetY },
                { x: targetX - 1, y: targetY },
                { x: targetX, y: targetY + 1 },
                { x: targetX, y: targetY - 1 }
            ];

            // Destroy hazard
            for (const pos of adjacent) {
                const idx = state.hazards.findIndex(h => h.x === pos.x && h.y === pos.y);
                if (idx !== -1) {
                    const hazard = state.hazards[idx];
                    state.hazards.splice(idx, 1);
                    state.score += 5;
                    state.stats.totalHazardsDestroyed++;
                    createParticles(hazard.x, hazard.y, '#FF4444', 15);
                    playDestroy();
                    // Screen shake on destroy
                    const canvas = document.getElementById('game-canvas');
                    canvas.classList.add('shake');
                    setTimeout(() => canvas.classList.remove('shake'), 300);
                    hapticFeedback('medium');
                    updateUI();
                    if (state.tutorialActive) checkTutorialProgress('destroy');
                    return;
                }
            }

            // Destroy enemy
            for (const pos of adjacent) {
                const idx = state.enemies.findIndex(e => e.x === pos.x && e.y === pos.y);
                if (idx !== -1) {
                    const enemy = state.enemies[idx];
                    state.enemies.splice(idx, 1);
                    state.score += 5;
                    state.stats.totalHazardsDestroyed++;
                    createParticles(enemy.x, enemy.y, '#FF4444', 15);
                    playDestroy();
                    const canvas = document.getElementById('game-canvas');
                    canvas.classList.add('shake');
                    setTimeout(() => canvas.classList.remove('shake'), 300);
                    hapticFeedback('medium');
                    updateUI();
                    if (state.tutorialActive) checkTutorialProgress('destroy');
                    return;
                }
            }
        }

        // ===== REVEAL PULSE =====
        function activateRevealPulse() {
            if (!state.gameStarted || state.gamePaused || state.gameOver) return;
            if (state.revealUsesLeft <= 0 || state.revealPulseActive) return;
            state.revealUsesLeft--;
            state.revealPulseActive = true;
            state.revealPulseTimer = 120;
            for (let y = 0; y < state.mazeHeight; y++) {
                for (let x = 0; x < state.mazeWidth; x++) {
                    state.exploredTiles[y][x] = true;
                }
            }
            playTone(1000, 0.1, 'sine', 0.03);
            setTimeout(() => playTone(1200, 0.1, 'sine', 0.03), 50);
            hapticFeedback('medium');
            updateUI();
            if (state.tutorialActive) checkTutorialProgress('reveal');
        }

        // ===== LEVEL TRANSITION =====
        function startLevelTransition(callback) {
            state.transitioning = true;
            state.transitionPhase = 'dissolve';

            const tiles = [];
            for (let y = 0; y < state.mazeHeight; y++) {
                for (let x = 0; x < state.mazeWidth; x++) {
                    tiles.push({ x, y });
                }
            }
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }
            state.transitionTiles = tiles;
            state.transitionTimer = 0;

            const dissolveInterval = setInterval(() => {
                state.transitionTimer += 20;
                if (state.transitionTimer >= 500) {
                    clearInterval(dissolveInterval);
                    callback();
                    state.transitionPhase = 'build';
                    state.transitionTimer = 0;
                    const buildInterval = setInterval(() => {
                        state.transitionTimer += 20;
                        if (state.transitionTimer >= 500) {
                            clearInterval(buildInterval);
                            state.transitioning = false;
                            state.transitionPhase = 'none';
                        }
                    }, 20);
                }
            }, 20);
        }

        // ===== TUTORIAL SYSTEM =====
        function isTutorialNeeded() {
            return !localStorage.getItem('mazeTutorialComplete');
        }

        function getTutorialMaze() {
            return [
                [1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,0,1],
                [1,0,1,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1]
            ];
        }

        function startTutorial() {
            state.tutorialActive = true;
            state.tutorialStep = 0;
            state.tutorialMoveCount = 0;
            state.tutorialPromptTimer = 0;

            state.gameStarted = true;
            state.gameOver = false;
            state.gamePaused = false;
            state.score = 0;
            state.level = 1;
            state.combo = 0;
            state.comboTimer = 0;
            state.timeLeft = 999;
            state.lastTimerTickSecond = -1;

            state.mazeWidth = 9;
            state.mazeHeight = 9;
            state.goal = { x: 7, y: 7 };
            state.player = { x: 1, y: 1, targetX: 1, targetY: 1, animProgress: 1 };
            state.maze = getTutorialMaze();

            state.hazards = [];
            state.collectibles = [];
            state.powerups = [];
            state.enemies = [];
            state.particles = [];
            state.floatingTexts = [];
            state.enemyMoveTimer = 0;

            state.speedBoost = false;
            state.speedBoostTimer = 0;
            state.hasShield = false;
            state.magnetActive = false;
            state.magnetTimer = 0;
            state.freezeActive = false;
            state.freezeTimer = 0;

            state.transitioning = false;
            state.transitionPhase = 'none';

            // Fog OFF for initial steps
            state.fogEnabled = false;
            state.exploredTiles = Array(9).fill(null).map(() => Array(9).fill(true));
            state.revealPulseActive = false;
            state.revealPulseTimer = 0;
            state.revealUsesLeft = 0;

            // Place gem for step 1/2
            state.collectibles.push({ x: 4, y: 1, rotation: 0 });

            startBackgroundMusic();
            requestWakeLock();
            hapticFeedback('medium');

            state.tileSize = calculateTileSize();
            state.canvas.width = state.mazeWidth * state.tileSize;
            state.canvas.height = state.mazeHeight * state.tileSize;

            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('speed-indicator').classList.add('hidden');
            document.getElementById('shield-indicator').classList.add('hidden');
            document.getElementById('magnet-indicator').classList.add('hidden');
            document.getElementById('freeze-indicator').classList.add('hidden');
            document.getElementById('tutorial-skip-btn').classList.remove('hidden');

            updateTutorialUI();
        }

        function advanceTutorialStep() {
            state.tutorialStep++;
            state.tutorialPromptTimer = 0;
            hapticFeedback('light');
            // Brief ascending tone for step completion
            playTone(800, 0.05, 'square', 0.02);
            setTimeout(() => playTone(1000, 0.05, 'square', 0.02), 60);

            switch (state.tutorialStep) {
                case 1:
                    // Gem should still be at (4,1); if already collected during movement, re-add
                    if (state.collectibles.length === 0) {
                        state.collectibles.push({ x: 4, y: 1, rotation: 0 });
                    }
                    break;

                case 2: {
                    // Place hazard adjacent to player's current position
                    const px = state.player.targetX;
                    const py = state.player.targetY;
                    // Try right, then down, then left, then up
                    const candidates = [
                        { x: px + 1, y: py },
                        { x: px, y: py + 1 },
                        { x: px - 1, y: py },
                        { x: px, y: py - 1 }
                    ];
                    for (const c of candidates) {
                        if (c.x > 0 && c.x < 8 && c.y > 0 && c.y < 8 &&
                            state.maze[c.y][c.x] === 0) {
                            state.hazards.push({ x: c.x, y: c.y, pulse: 0 });
                            break;
                        }
                    }
                    break;
                }

                case 3:
                    // Enable fog of war + give 1 reveal use
                    state.fogEnabled = true;
                    state.exploredTiles = Array(9).fill(null).map(() => Array(9).fill(false));
                    markExplored(state.player.targetX, state.player.targetY, 4);
                    state.revealUsesLeft = 1;
                    updateTutorialUI();
                    break;

                case 4:
                    // Goal already at (7,7), just let them find it
                    break;

                case 5:
                    completeTutorial();
                    return;
            }
        }

        function checkTutorialProgress(event) {
            if (!state.tutorialActive) return;

            switch (state.tutorialStep) {
                case 0:
                    if (event === 'move') {
                        state.tutorialMoveCount++;
                        if (state.tutorialMoveCount >= 3) advanceTutorialStep();
                    }
                    break;
                case 1:
                    if (event === 'collect') advanceTutorialStep();
                    break;
                case 2:
                    if (event === 'destroy') advanceTutorialStep();
                    break;
                case 3:
                    if (event === 'reveal') advanceTutorialStep();
                    break;
                case 4:
                    if (event === 'goal') advanceTutorialStep();
                    break;
            }
        }

        function completeTutorial() {
            state.tutorialActive = false;
            localStorage.setItem('mazeTutorialComplete', 'true');
            document.getElementById('tutorial-skip-btn').classList.add('hidden');

            playWin();
            hapticFeedback('medium');

            // Show "TRAINING COMPLETE!" using level-complete overlay
            const overlay = document.getElementById('level-complete');
            const h2 = overlay.querySelector('h2');
            const origText = h2.textContent;
            h2.textContent = 'TRAINING DONE!';
            document.getElementById('level-bonus').textContent = '0';
            overlay.classList.remove('hidden');

            let countdown = 2;
            const timerEl = document.getElementById('next-level-timer');
            timerEl.textContent = countdown;
            const interval = setInterval(() => {
                countdown--;
                timerEl.textContent = countdown;
                if (countdown <= 0) {
                    clearInterval(interval);
                    h2.textContent = origText;
                    overlay.classList.add('hidden');

                    startLevelTransition(() => {
                        setupLevel1AfterTutorial();
                    });
                }
            }, 1000);
        }

        function skipTutorial() {
            state.tutorialActive = false;
            state.gameStarted = false;
            localStorage.setItem('mazeTutorialComplete', 'true');
            document.getElementById('tutorial-skip-btn').classList.add('hidden');
            startGame();
        }

        function setupLevel1AfterTutorial() {
            const diff = DIFFICULTY[state.difficulty];

            state.level = 1;
            state.score = 0;
            state.combo = 0;
            state.comboTimer = 0;
            state.timeLeft = diff.time;
            state.lastTimerTickSecond = -1;

            const size = getMazeSize(1);
            state.mazeWidth = size.w;
            state.mazeHeight = size.h;
            state.goal = { x: size.w - 2, y: size.h - 2 };
            state.player = { x: 1, y: 1, targetX: 1, targetY: 1, animProgress: 1 };

            state.speedBoost = false;
            state.speedBoostTimer = 0;
            state.hasShield = false;
            state.magnetActive = false;
            state.magnetTimer = 0;
            state.freezeActive = false;
            state.freezeTimer = 0;
            state.particles = [];
            state.floatingTexts = [];
            state.enemies = [];
            state.enemyMoveTimer = 0;
            state.transitioning = false;
            state.transitionPhase = 'none';

            state.fogEnabled = true;
            state.exploredTiles = Array(state.mazeHeight).fill(null).map(() => Array(state.mazeWidth).fill(false));
            state.revealPulseActive = false;
            state.revealPulseTimer = 0;
            state.revealUsesLeft = diff.revealUses;

            state.stats.totalGames++;
            saveStats();

            state.tileSize = calculateTileSize();
            state.canvas.width = state.mazeWidth * state.tileSize;
            state.canvas.height = state.mazeHeight * state.tileSize;

            generateMaze();
            markExplored(1, 1, 4);

            document.getElementById('speed-indicator').classList.add('hidden');
            document.getElementById('shield-indicator').classList.add('hidden');
            document.getElementById('magnet-indicator').classList.add('hidden');
            document.getElementById('freeze-indicator').classList.add('hidden');

            updateUI();
            state.gameStarted = true;
        }

        function drawTutorialPrompt() {
            const { ctx, canvas, tileSize, gbColors, isMobile } = state;

            const prompts = isMobile
                ? ['SWIPE D-PAD TO MOVE', 'WALK OVER GEMS *', 'PRESS B: ATTACK!', 'PRESS A: REVEAL MAP!', 'REACH THE FLAG!']
                : ['ARROWS/WASD: MOVE', 'WALK OVER GEMS *', 'SPACE: ATTACK!', 'E KEY: REVEAL MAP!', 'REACH THE FLAG!'];

            const text = prompts[state.tutorialStep] || '';

            state.tutorialPromptTimer += 0.03;
            const alpha = 0.7 + 0.3 * Math.abs(Math.sin(state.tutorialPromptTimer * 2));

            const boxH = Math.max(tileSize * 1.4, 18);
            const boxY = 2;
            const boxX = 4;
            const boxW = canvas.width - 8;

            ctx.globalAlpha = 0.92;
            ctx.fillStyle = gbColors.darkest;
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = gbColors.lightest;
            ctx.lineWidth = 2;
            ctx.strokeRect(boxX, boxY, boxW, boxH);

            ctx.globalAlpha = alpha;
            ctx.fillStyle = gbColors.lightest;
            const fontSize = Math.max(7, Math.min(tileSize * 0.32, 11));
            ctx.font = `bold ${fontSize}px 'Press Start 2P', monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, boxY + boxH / 2);

            ctx.globalAlpha = 1;
        }

        function updateTutorialUI() {
            document.getElementById('score').textContent = 'SC:0000';
            document.getElementById('level').textContent = 'TUTO';
            document.getElementById('timer').textContent = '';
            document.getElementById('timer').classList.remove('blink');
            document.getElementById('reveal-uses').textContent = state.revealUsesLeft > 0 ? `A:${state.revealUsesLeft}` : '';
            document.getElementById('combo').classList.add('hidden');
        }

        // ===== GAME FLOW =====
        function levelComplete() {
            const diff = DIFFICULTY[state.difficulty];
            const timeBonus = state.timeLeft * 2;
            state.score += timeBonus;

            // Track fastest level clear
            const timeUsed = diff.time - state.timeLeft;
            if (timeUsed < state.stats.fastestLevelClear) {
                state.stats.fastestLevelClear = timeUsed;
            }
            saveStats();

            document.getElementById('level-bonus').textContent = timeBonus;
            document.getElementById('level-complete').classList.remove('hidden');
            playWin();
            hapticFeedback('success');

            let countdown = 3;
            const timerEl = document.getElementById('next-level-timer');
            const interval = setInterval(() => {
                countdown--;
                timerEl.textContent = countdown;
                if (countdown <= 0) {
                    clearInterval(interval);
                    document.getElementById('level-complete').classList.add('hidden');
                    startLevelTransition(() => {
                        nextLevel();
                    });
                }
            }, 1000);
        }

        function nextLevel() {
            const diff = DIFFICULTY[state.difficulty];
            state.level++;

            // Update maze size based on level
            const size = getMazeSize(state.level);
            state.mazeWidth = size.w;
            state.mazeHeight = size.h;
            state.goal = { x: size.w - 2, y: size.h - 2 };

            state.player = { x: 1, y: 1, targetX: 1, targetY: 1, animProgress: 1 };
            state.timeLeft = Math.max(30, diff.time - state.level * 2);
            state.lastTimerTickSecond = -1;
            state.speedBoost = false;
            state.speedBoostTimer = 0;
            state.hasShield = false;
            state.magnetActive = false;
            state.magnetTimer = 0;
            state.freezeActive = false;
            state.freezeTimer = 0;
            state.enemies = [];
            state.enemyMoveTimer = 0;
            state.particles = [];
            state.floatingTexts = [];
            state.transitioning = false;
            state.transitionPhase = 'none';

            // Fog of war reset
            state.exploredTiles = Array(state.mazeHeight).fill().map(() => Array(state.mazeWidth).fill(false));
            state.revealPulseActive = false;
            state.revealPulseTimer = 0;
            state.revealUsesLeft = diff.revealUses;

            // Resize canvas
            state.tileSize = calculateTileSize();
            state.canvas.width = state.mazeWidth * state.tileSize;
            state.canvas.height = state.mazeHeight * state.tileSize;

            generateMaze();
            markExplored(1, 1, 4);

            document.getElementById('level-complete').classList.add('hidden');
            document.getElementById('speed-indicator').classList.add('hidden');
            document.getElementById('shield-indicator').classList.add('hidden');
            document.getElementById('magnet-indicator').classList.add('hidden');
            document.getElementById('freeze-indicator').classList.add('hidden');
            updateUI();
        }

        function gameOverScreen(won) {
            state.gameOver = true;
            state.gameStarted = false;

            // Release wake lock when game ends
            releaseWakeLock();

            const overlay = document.getElementById('game-over');

            if (won) {
                // Victory - bright screen, triumphant fanfare
                overlay.style.background = '#8bac0f';
                overlay.style.color = '#0f380f';
                document.getElementById('game-over-title').textContent = 'VICTORY!';
                playWin();
                setTimeout(() => {
                    [1047, 1318, 1568].forEach((f, i) =>
                        setTimeout(() => playTone(f, 0.2, 'square', 0.04), i * 100)
                    );
                }, 500);
                hapticFeedback('success');
            } else {
                // Game over - darker screen, sad tones
                overlay.style.background = '#306230';
                overlay.style.color = '#9bbc0f';
                document.getElementById('game-over-title').textContent = "TIME'S UP!";
                playLose();
                hapticFeedback('error');
            }

            saveStats();

            const isNewHighScore = state.score > state.highScore;
            if (isNewHighScore) {
                state.highScore = state.score;
                localStorage.setItem('mazeHighScore', state.score.toString());
                hapticFeedback('success');
            }

            // Add score to leaderboard
            if (state.score > 0) {
                addToLeaderboard(state.playerName, state.score, state.level);
            }

            document.getElementById('final-score').textContent = state.score;
            document.getElementById('final-level').textContent = state.level;
            document.getElementById('new-high-score').classList.toggle('hidden', !isNewHighScore);
            overlay.classList.remove('hidden');
        }

        function startGame() {
            const diff = DIFFICULTY[state.difficulty];
            state.gameStarted = false;
            state.gameOver = false;
            state.gamePaused = false;
            state.score = 0;
            state.level = 1;
            state.combo = 0;
            state.timeLeft = diff.time;
            state.lastTimerTickSecond = -1;

            // Set maze size for level 1
            const size = getMazeSize(1);
            state.mazeWidth = size.w;
            state.mazeHeight = size.h;
            state.goal = { x: size.w - 2, y: size.h - 2 };
            state.player = { x: 1, y: 1, targetX: 1, targetY: 1, animProgress: 1 };

            state.speedBoost = false;
            state.speedBoostTimer = 0;
            state.hasShield = false;
            state.magnetActive = false;
            state.magnetTimer = 0;
            state.freezeActive = false;
            state.freezeTimer = 0;
            state.particles = [];
            state.floatingTexts = [];
            state.enemies = [];
            state.enemyMoveTimer = 0;
            state.transitioning = false;
            state.transitionPhase = 'none';

            // Fog of war
            state.exploredTiles = Array(state.mazeHeight).fill().map(() => Array(state.mazeWidth).fill(false));
            state.revealPulseActive = false;
            state.revealPulseTimer = 0;
            state.revealUsesLeft = diff.revealUses;

            // Stats
            state.stats.totalGames++;
            saveStats();

            // Start background music on first game start
            startBackgroundMusic();

            // Request screen wake lock to prevent screen dimming during gameplay
            requestWakeLock();

            // Haptic feedback for game start
            hapticFeedback('medium');

            // Resize canvas for maze dimensions
            state.tileSize = calculateTileSize();
            state.canvas.width = state.mazeWidth * state.tileSize;
            state.canvas.height = state.mazeHeight * state.tileSize;

            generateMaze();

            // Mark starting area as explored
            markExplored(1, 1, 4);

            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('speed-indicator').classList.add('hidden');
            document.getElementById('shield-indicator').classList.add('hidden');
            document.getElementById('magnet-indicator').classList.add('hidden');
            document.getElementById('freeze-indicator').classList.add('hidden');

            updateUI();

            // Countdown
            const countdownEl = document.getElementById('countdown');
            countdownEl.classList.remove('hidden');
            let count = 3;
            countdownEl.querySelector('span').textContent = count;

            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.querySelector('span').textContent = count;
                    playTone(440, 0.1, 'sine', 0.04);
                    hapticFeedback('light');
                } else {
                    countdownEl.classList.add('hidden');
                    playTone(880, 0.2, 'sine', 0.05);
                    hapticFeedback('success');
                    state.gameStarted = true;
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        function updateUI() {
            if (state.tutorialActive) { updateTutorialUI(); return; }
            // Format score with leading zeros (GB style)
            const scoreStr = String(state.score).padStart(4, '0');
            document.getElementById('score').textContent = `SC:${scoreStr}`;

            // Timer
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `T:${String(state.timeLeft).padStart(2, '0')}`;
            // Flash when low time
            if (state.timeLeft <= 10) {
                timerEl.classList.add('blink');
            } else {
                timerEl.classList.remove('blink');
            }

            // Level with leading zero
            document.getElementById('level').textContent = `LV:${String(state.level).padStart(2, '0')}`;

            // Combo indicator
            const comboEl = document.getElementById('combo');
            if (state.combo > 1) {
                comboEl.textContent = `x${state.combo}!`;
                comboEl.classList.remove('hidden');
            } else {
                comboEl.classList.add('hidden');
            }

            // Reveal uses counter
            document.getElementById('reveal-uses').textContent = `A:${state.revealUsesLeft}`;
        }

        // ===== RENDERING (Game Boy Style) =====
        const ENTITY_LOGO_COLORS = {
            c22: '#005f00',
            c28: '#008700',
            c70: '#5f8700'
        };

        const ENTITY_LOGOS = {
            player: {
                pattern: [
                    '  ___  ',
                    ' /   \\ ',
                    '/ @ @ \\',
                    '\\  -  /',
                    '  ___/ '
                ],
                rowColors: ['c22', 'c28', 'c70', 'c28', 'c22']
            },
            gem: {
                pattern: [
                    '   *   ',
                    '  * *  ',
                    ' *   * ',
                    '  * *  ',
                    '   *   ',
                    '  ***  '
                ],
                rowColors: ['c22', 'c28', 'c70', 'c70', 'c28', 'c22']
            },
            hazard: {
                pattern: [
                    ' \\   / ',
                    '  \\ /  ',
                    '   X   ',
                    '  / \\  ',
                    ' /   \\ ',
                    ' ***** '
                ],
                rowColors: ['c22', 'c28', 'c70', 'c70', 'c28', 'c22']
            },
            enemy: {
                pattern: [
                    ' /^^^\\ ',
                    '| M M |',
                    ' \\ V / ',
                    '  _/   ',
                    ' /   \\ ',
                    '/_____\\'
                ],
                rowColors: ['c22', 'c28', 'c70', 'c70', 'c28', 'c22']
            }
        };

        function escapeLogoChar(ch) {
            if (ch === '&') return '&amp;';
            if (ch === '<') return '&lt;';
            if (ch === '>') return '&gt;';
            return ch;
        }

        function logoRowToHtml(row) {
            let html = '';
            for (const ch of row) {
                html += ch === ' ' ? '&nbsp;' : escapeLogoChar(ch);
            }
            return html;
        }

        function renderCharacterSelectionLogos() {
            const playerLogo = ENTITY_LOGOS.player;
            document.querySelectorAll('#characters .character-btn').forEach(btn => {
                const charKey = btn.dataset.char;
                const symbol = String(state.characterMap[charKey] || '@').charAt(0);
                const rows = playerLogo.pattern.map(row => row.replace(/@/g, () => symbol));
                const logoEl = btn.querySelector('.character-logo');
                if (!logoEl) return;

                logoEl.innerHTML = rows.map((row, idx) => {
                    const colorKey = playerLogo.rowColors[idx] || playerLogo.rowColors[playerLogo.rowColors.length - 1];
                    const color = ENTITY_LOGO_COLORS[colorKey] || ENTITY_LOGO_COLORS.c70;
                    return `<span class="character-logo-row" style="color:${color};">${logoRowToHtml(row)}</span>`;
                }).join('');
            });
        }

        function drawLogoTile(tileX, tileY, logo, offsetX = 0, offsetY = 0) {
            const { ctx, tileSize } = state;
            const rows = logo.pattern;
            const rowCount = rows.length;
            const colCount = Math.max(...rows.map(r => r.length));

            const inset = Math.max(1, Math.floor(tileSize * 0.08));
            const available = tileSize - inset * 2;
            const cellSize = Math.max(1, Math.floor(Math.min(available / colCount, available / rowCount)));
            const logoWidth = colCount * cellSize;
            const logoHeight = rowCount * cellSize;

            const startX = Math.floor(tileX * tileSize + (tileSize - logoWidth) / 2 + offsetX);
            const startY = Math.floor(tileY * tileSize + (tileSize - logoHeight) / 2 + offsetY);

            for (let row = 0; row < rowCount; row++) {
                const colorKey = logo.rowColors[row] || logo.rowColors[logo.rowColors.length - 1];
                ctx.fillStyle = ENTITY_LOGO_COLORS[colorKey] || ENTITY_LOGO_COLORS.c70;

                for (let col = 0; col < colCount; col++) {
                    const ch = rows[row][col];
                    if (!ch || ch === ' ') continue;
                    ctx.fillRect(startX + col * cellSize, startY + row * cellSize, cellSize, cellSize);
                }
            }
        }

        function draw() {
            const { ctx, canvas, tileSize, maze, mazeWidth, mazeHeight, player, goal, hazards, collectibles, powerups, particles, gbColors } = state;

            // Clear with lightest GB color
            ctx.fillStyle = gbColors.lightest;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze with GB colors
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        // Wall - darkest color with simple block pattern
                        ctx.fillStyle = gbColors.darkest;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                        // Inner highlight for depth
                        ctx.fillStyle = gbColors.dark;
                        ctx.fillRect(x * tileSize + 2, y * tileSize + 2, tileSize - 4, tileSize - 4);
                    } else {
                        // Floor - light color
                        ctx.fillStyle = gbColors.light;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                        // Grid lines for retro look
                        ctx.strokeStyle = gbColors.lightest;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Draw goal - pulsing flag pattern
            const goalPulse = Math.floor(Date.now() / 300) % 2;
            ctx.fillStyle = goalPulse ? gbColors.dark : gbColors.darkest;
            ctx.fillRect(goal.x * tileSize + 2, goal.y * tileSize + 2, tileSize - 4, tileSize - 4);
            // Draw 'F' for flag/finish
            ctx.fillStyle = gbColors.lightest;
            ctx.font = `bold ${tileSize * 0.6}px 'Press Start 2P', monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('F', goal.x * tileSize + tileSize / 2, goal.y * tileSize + tileSize / 2);

            // Draw hazards - styled cross/trap logo
            hazards.forEach(h => {
                h.pulse += 0.1;
                const flash = Math.floor(h.pulse) % 2;
                ctx.fillStyle = flash ? gbColors.darkest : gbColors.dark;
                ctx.fillRect(h.x * tileSize + 1, h.y * tileSize + 1, tileSize - 2, tileSize - 2);
                drawLogoTile(h.x, h.y, ENTITY_LOGOS.hazard);
            });

            // Draw collectibles - styled gem logo
            collectibles.forEach(c => {
                c.rotation += 0.08;
                const bob = Math.floor(c.rotation) % 2 ? 1 : -1;
                ctx.fillStyle = gbColors.dark;
                ctx.fillRect(c.x * tileSize + 2, c.y * tileSize + 2 + bob, tileSize - 4, tileSize - 4);
                drawLogoTile(c.x, c.y, ENTITY_LOGOS.gem, 0, bob);
            });

            // Draw powerups
            powerups.forEach(p => {
                p.pulse += 0.1;
                const scale = Math.floor(p.pulse) % 2;
                const offset = scale ? 2 : 4;
                ctx.fillStyle = gbColors.dark;
                ctx.fillRect(p.x * tileSize + offset, p.y * tileSize + offset, tileSize - offset * 2, tileSize - offset * 2);
                // Draw ! for powerup
                ctx.fillStyle = gbColors.lightest;
                ctx.font = `bold ${tileSize * 0.45}px 'Press Start 2P', monospace`;
                const iconMap = { speed: '!', time: '+', shield: 'S', reveal: '?', magnet: 'U', freeze: '*' };
                const icon = iconMap[p.type] || '!';
                ctx.fillText(icon, p.x * tileSize + tileSize / 2, p.y * tileSize + tileSize / 2);
            });

            // Draw enemies - styled monster logo
            state.enemies.forEach(e => {
                const flash = Math.floor(Date.now() / 200) % 2;
                ctx.fillStyle = flash ? gbColors.darkest : gbColors.dark;
                ctx.fillRect(e.x * tileSize + 2, e.y * tileSize + 2, tileSize - 4, tileSize - 4);
                drawLogoTile(e.x, e.y, ENTITY_LOGOS.enemy);
            });

            // Draw particles - simple squares
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = gbColors.darkest;
                const size = Math.max(2, Math.floor(p.size * p.life));
                ctx.fillRect(Math.floor(p.x), Math.floor(p.y), size, size);
            });
            ctx.globalAlpha = 1;

            // Animate player
            if (player.animProgress < 1) {
                player.animProgress += 0.2;
                if (player.animProgress > 1) player.animProgress = 1;

                const ease = 1 - Math.pow(1 - player.animProgress, 3);
                player.x = player.x + (player.targetX - player.x) * ease;
                player.y = player.y + (player.targetY - player.y) * ease;
            } else {
                player.x = player.targetX;
                player.y = player.targetY;
            }

            // Draw player - styled avatar logo
            const px = Math.floor(player.x * tileSize);
            const py = Math.floor(player.y * tileSize);

            // Player background
            ctx.fillStyle = gbColors.darkest;
            ctx.fillRect(px + 2, py + 2, tileSize - 4, tileSize - 4);

            // Preserve selected character by swapping the avatar eye symbol.
            const avatarSymbol = String(state.character || '@').charAt(0);
            const playerLogo = {
                pattern: ENTITY_LOGOS.player.pattern.map(row => row.replace(/@/g, () => avatarSymbol)),
                rowColors: ENTITY_LOGOS.player.rowColors
            };
            drawLogoTile(player.x, player.y, playerLogo);

            // Speed boost effect - flashing border
            if (state.speedBoost) {
                const flash = Math.floor(Date.now() / 100) % 2;
                if (flash) {
                    ctx.strokeStyle = gbColors.darkest;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px, py, tileSize, tileSize);
                }
            }

            // Shield indicator on player
            if (state.hasShield) {
                ctx.strokeStyle = gbColors.lightest;
                ctx.lineWidth = 2;
                ctx.strokeRect(px - 1, py - 1, tileSize + 2, tileSize + 2);
            }

            // Draw floating text
            state.floatingTexts.forEach(ft => {
                ctx.globalAlpha = ft.life;
                ctx.fillStyle = gbColors.darkest;
                ctx.font = `bold ${tileSize * 0.35}px 'Press Start 2P', monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ft.text, ft.x, ft.y);
            });
            ctx.globalAlpha = 1;

            // ===== FOG OF WAR OVERLAY =====
            if (state.fogEnabled && !state.revealPulseActive) {
                const playerTX = state.player.targetX;
                const playerTY = state.player.targetY;

                for (let y = 0; y < mazeHeight; y++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        const dist = Math.abs(x - playerTX) + Math.abs(y - playerTY);
                        if (dist <= 4) continue; // Fully visible

                        if (state.exploredTiles[y][x]) {
                            ctx.fillStyle = 'rgba(15, 56, 15, 0.6)';
                        } else {
                            ctx.fillStyle = gbColors.darkest;
                        }
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // ===== MINIMAP =====
            if (state.gameStarted && !state.gameOver) {
                const mmScale = Math.max(1, Math.floor(60 / Math.max(mazeWidth, mazeHeight)));
                const mmW = mazeWidth * mmScale;
                const mmH = mazeHeight * mmScale;
                const mmX = canvas.width - mmW - 4;
                const mmY = 4;

                // Background
                ctx.fillStyle = 'rgba(155, 188, 15, 0.85)';
                ctx.fillRect(mmX - 1, mmY - 1, mmW + 2, mmH + 2);
                ctx.strokeStyle = gbColors.darkest;
                ctx.lineWidth = 1;
                ctx.strokeRect(mmX - 1, mmY - 1, mmW + 2, mmH + 2);

                for (let y = 0; y < mazeHeight; y++) {
                    for (let x = 0; x < mazeWidth; x++) {
                        if (!state.exploredTiles[y][x] && state.fogEnabled && !state.revealPulseActive) {
                            ctx.fillStyle = gbColors.darkest;
                        } else if (maze[y][x] === 1) {
                            ctx.fillStyle = gbColors.dark;
                        } else {
                            ctx.fillStyle = gbColors.light;
                        }
                        ctx.fillRect(mmX + x * mmScale, mmY + y * mmScale, mmScale, mmScale);
                    }
                }

                // Player dot
                ctx.fillStyle = gbColors.lightest;
                ctx.fillRect(mmX + state.player.targetX * mmScale, mmY + state.player.targetY * mmScale, Math.max(mmScale, 2), Math.max(mmScale, 2));

                // Goal dot (if explored or visible)
                const goalDist = Math.abs(state.goal.x - state.player.targetX) + Math.abs(state.goal.y - state.player.targetY);
                if (goalDist <= 4 || state.exploredTiles[state.goal.y][state.goal.x] || state.revealPulseActive) {
                    ctx.fillStyle = gbColors.darkest;
                    ctx.fillRect(mmX + state.goal.x * mmScale, mmY + state.goal.y * mmScale, Math.max(mmScale, 2), Math.max(mmScale, 2));
                }
            }

            // ===== LEVEL TRANSITION OVERLAY =====
            if (state.transitioning && state.transitionTiles.length > 0) {
                const progress = Math.min(state.transitionTimer / 500, 1);
                const tilesToCover = Math.floor(state.transitionTiles.length * progress);

                if (state.transitionPhase === 'dissolve') {
                    for (let i = 0; i < tilesToCover; i++) {
                        const t = state.transitionTiles[i];
                        ctx.fillStyle = gbColors.darkest;
                        ctx.fillRect(t.x * tileSize, t.y * tileSize, tileSize, tileSize);
                    }
                } else if (state.transitionPhase === 'build') {
                    for (let i = tilesToCover; i < state.transitionTiles.length; i++) {
                        const t = state.transitionTiles[i];
                        ctx.fillStyle = gbColors.darkest;
                        ctx.fillRect(t.x * tileSize, t.y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Tutorial prompt overlay
            if (state.tutorialActive) drawTutorialPrompt();
        }

        // ===== GAME LOOP =====
        let lastTime = 0;
        let timerAccum = 0;
        
        function gameLoop(timestamp) {
            const delta = timestamp - lastTime;
            lastTime = timestamp;
            
            if (state.gameStarted && !state.gamePaused && !state.gameOver) {
                // Timer (skip during tutorial)
                timerAccum += delta;
                if (timerAccum >= 1000) {
                    timerAccum -= 1000;
                    if (!state.tutorialActive) {
                        if (!state.freezeActive) {
                            state.timeLeft--;
                        }
                        state.stats.totalTimePlayed++;
                        updateUI();

                        // Timer warning sound
                        if (state.timeLeft <= 10 && state.timeLeft > 0 && state.timeLeft !== state.lastTimerTickSecond) {
                            state.lastTimerTickSecond = state.timeLeft;
                            const freq = 400 + (10 - state.timeLeft) * 40;
                            playTone(freq, 0.05, 'square', 0.025);
                            hapticFeedback('light');
                        }

                        if (state.timeLeft <= 0) {
                            saveStats();
                            gameOverScreen(false);
                        }
                    }
                }

                // Combo timer
                if (state.comboTimer > 0) {
                    state.comboTimer--;
                    if (state.comboTimer <= 0) {
                        state.combo = 0;
                        updateUI();
                    }
                }

                // Speed boost timer
                if (state.speedBoost) {
                    state.speedBoostTimer--;
                    if (state.speedBoostTimer <= 0) {
                        state.speedBoost = false;
                        document.getElementById('speed-indicator').classList.add('hidden');
                    }
                }

                // Magnet effect
                if (state.magnetActive) {
                    state.magnetTimer--;
                    if (state.magnetTimer <= 0) {
                        state.magnetActive = false;
                        document.getElementById('magnet-indicator').classList.add('hidden');
                    } else {
                        const mpx = state.player.targetX;
                        const mpy = state.player.targetY;
                        state.collectibles = state.collectibles.filter(c => {
                            if (Math.abs(c.x - mpx) <= 2 && Math.abs(c.y - mpy) <= 2) {
                                state.score += 10;
                                state.stats.totalGems++;
                                createParticles(c.x, c.y, '#FFD700', 6);
                                createFloatingText(c.x, c.y, '+10');
                                playCollect();
                                updateUI();
                                return false;
                            }
                            return true;
                        });
                    }
                }

                // Freeze timer
                if (state.freezeActive) {
                    state.freezeTimer--;
                    if (state.freezeTimer <= 0) {
                        state.freezeActive = false;
                        document.getElementById('freeze-indicator').classList.add('hidden');
                    }
                }

                // Reveal pulse timer
                if (state.revealPulseActive) {
                    state.revealPulseTimer--;
                    if (state.revealPulseTimer <= 0) {
                        state.revealPulseActive = false;
                    }
                }

                // Handle held keys
                if (!state.transitioning) {
                    const now = Date.now();
                    const delay = state.speedBoost ? state.moveDelay * 0.5 : state.moveDelay;
                    if (now - state.lastMoveTime >= delay) {
                        if (state.keysPressed['ArrowUp'] || state.keysPressed['KeyW']) movePlayer(0, -1);
                        else if (state.keysPressed['ArrowDown'] || state.keysPressed['KeyS']) movePlayer(0, 1);
                        else if (state.keysPressed['ArrowLeft'] || state.keysPressed['KeyA']) movePlayer(-1, 0);
                        else if (state.keysPressed['ArrowRight'] || state.keysPressed['KeyD']) movePlayer(1, 0);
                    }
                }

                // Update systems
                if (!state.tutorialActive) updateEnemies(delta);
                updateParticles();
                // Update floating text
                state.floatingTexts = state.floatingTexts.filter(ft => {
                    ft.y += ft.vy;
                    ft.life -= 0.02;
                    return ft.life > 0;
                });
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ===== INPUT =====
        function setupInput() {
            const isEditableTarget = (target) =>
                target instanceof Element &&
                (target.matches('input, textarea, [contenteditable=""], [contenteditable="true"]') ||
                 target.closest('input, textarea, [contenteditable=""], [contenteditable="true"]'));

            document.addEventListener('keydown', (e) => {
                if (isEditableTarget(e.target)) return;
                if (!state.audioCtx) initAudio();

                state.keysPressed[e.code] = true;

                if (e.code === 'Space') {
                    e.preventDefault();
                    destroyHazard();
                }

                if (e.code === 'KeyE') {
                    e.preventDefault();
                    activateRevealPulse();
                }

                if (e.code === 'KeyP' || e.code === 'Escape') {
                    e.preventDefault();
                    togglePause();
                }

                // Prevent scrolling
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                    e.preventDefault();
                }
            });

            document.addEventListener('keyup', (e) => {
                if (isEditableTarget(e.target)) return;
                state.keysPressed[e.code] = false;
            });

            // Track last touch time to prevent double-firing from touch + synthetic click
            let lastTouchTime = 0;
            const TOUCH_DEBOUNCE = 300; // ms
            const supportsPointerEvents = 'PointerEvent' in window;

            const isTouchLikeEvent = (event) => {
                if (event.type.startsWith('touch')) return true;
                if (event.type.startsWith('pointer')) {
                    return event.pointerType && event.pointerType !== 'mouse';
                }
                return false;
            };

            // Helper to create touch-aware handlers that prevent double-firing
            function createTouchHandler(handler, options = {}) {
                const { addPressedClass = false, element = null } = options;

                return function(e) {
                    const now = Date.now();
                    const isTouch = isTouchLikeEvent(e);

                    // Prevent double-firing: if this is a click shortly after a touch, ignore it
                    if (!isTouch && (now - lastTouchTime) < TOUCH_DEBOUNCE) {
                        e.preventDefault();
                        return;
                    }

                    if (isTouch) {
                        lastTouchTime = now;
                        e.preventDefault();
                    }

                    e.stopPropagation();

                    // Add visual feedback
                    if (addPressedClass && element) {
                        element.classList.add('pressed');
                        setTimeout(() => element.classList.remove('pressed'), 100);
                    }

                    handler(e);
                };
            }

            // D-Pad swipe controls — single overlay detects thumb swipes
            const dpadOverlay = document.getElementById('dpad-touch-overlay');
            const dpadContainer = document.getElementById('dpad-swipe-area');

            if (dpadOverlay && dpadContainer) {
                const SWIPE_THRESHOLD = 10; // pixels to trigger a move
                const HOLD_MOVE_INTERVAL = 120; // ms between repeated moves when holding
                const HOLD_START_DELAY = 180; // ms before hold-to-move kicks in
                let dpadTouchId = null;
                let dpadOriginX = 0;
                let dpadOriginY = 0;
                let dpadHoldDir = null;
                let dpadHoldInterval = null;
                let dpadHoldTimeout = null;
                let dpadLastDir = null;

                const dpadDoMove = (dir) => {
                    if (!state.audioCtx) initAudio();
                    hapticFeedback('light');
                    if (dir === 'up') movePlayer(0, -1);
                    else if (dir === 'down') movePlayer(0, 1);
                    else if (dir === 'left') movePlayer(-1, 0);
                    else if (dir === 'right') movePlayer(1, 0);
                };

                const setDpadFeedback = (dir) => {
                    dpadContainer.classList.remove('dir-up', 'dir-down', 'dir-left', 'dir-right');
                    if (dir) dpadContainer.classList.add('dir-' + dir);
                };

                const clearDpadState = () => {
                    dpadTouchId = null;
                    dpadHoldDir = null;
                    dpadLastDir = null;
                    if (dpadHoldInterval) {
                        clearInterval(dpadHoldInterval);
                        dpadHoldInterval = null;
                    }
                    if (dpadHoldTimeout) {
                        clearTimeout(dpadHoldTimeout);
                        dpadHoldTimeout = null;
                    }
                    setDpadFeedback(null);
                };

                const startHoldRepeat = (dir) => {
                    // Clear any existing hold
                    if (dpadHoldInterval) clearInterval(dpadHoldInterval);
                    if (dpadHoldTimeout) clearTimeout(dpadHoldTimeout);
                    dpadHoldDir = dir;
                    // Small delay before repeat starts
                    dpadHoldTimeout = setTimeout(() => {
                        dpadHoldInterval = setInterval(() => {
                            if (dpadHoldDir) dpadDoMove(dpadHoldDir);
                        }, HOLD_MOVE_INTERVAL);
                    }, HOLD_START_DELAY);
                };

                const getDirection = (dx, dy) => {
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    if (absDx < SWIPE_THRESHOLD && absDy < SWIPE_THRESHOLD) return null;
                    if (absDx > absDy) return dx < 0 ? 'left' : 'right';
                    return dy < 0 ? 'up' : 'down';
                };

                dpadOverlay.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (dpadTouchId !== null) return; // already tracking a finger
                    const touch = e.changedTouches[0];
                    dpadTouchId = touch.identifier;
                    dpadOriginX = touch.clientX;
                    dpadOriginY = touch.clientY;
                    dpadLastDir = null;
                    lastTouchTime = Date.now();
                }, { passive: false });

                dpadOverlay.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    let touch = null;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === dpadTouchId) {
                            touch = e.changedTouches[i];
                            break;
                        }
                    }
                    if (!touch) return;

                    const dx = touch.clientX - dpadOriginX;
                    const dy = touch.clientY - dpadOriginY;
                    const dir = getDirection(dx, dy);

                    if (dir) {
                        setDpadFeedback(dir);

                        // Fire move and reset origin so next swipe starts from here
                        dpadDoMove(dir);
                        dpadOriginX = touch.clientX;
                        dpadOriginY = touch.clientY;

                        // Start or update hold-to-move if direction changed
                        if (dir !== dpadHoldDir) {
                            startHoldRepeat(dir);
                        }
                        dpadLastDir = dir;
                    }
                }, { passive: false });

                const handleDpadEnd = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    let found = false;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === dpadTouchId) {
                            found = true;
                            // Check for tap (no significant movement) — treat as up
                            const touch = e.changedTouches[i];
                            const dx = touch.clientX - dpadOriginX;
                            const dy = touch.clientY - dpadOriginY;
                            if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD && !dpadLastDir) {
                                // Tap on d-pad without swipe — no action (require directional input)
                            }
                            break;
                        }
                    }
                    if (found || e.touches.length === 0) {
                        clearDpadState();
                    }
                };

                dpadOverlay.addEventListener('touchend', handleDpadEnd, { passive: false });
                dpadOverlay.addEventListener('touchcancel', handleDpadEnd, { passive: false });

                // Also support mouse for desktop testing
                let mouseDown = false;
                dpadOverlay.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const now = Date.now();
                    if ((now - lastTouchTime) < TOUCH_DEBOUNCE) return;
                    mouseDown = true;
                    dpadOriginX = e.clientX;
                    dpadOriginY = e.clientY;
                    dpadLastDir = null;
                });
                dpadOverlay.addEventListener('mousemove', (e) => {
                    if (!mouseDown) return;
                    e.preventDefault();
                    const dx = e.clientX - dpadOriginX;
                    const dy = e.clientY - dpadOriginY;
                    const dir = getDirection(dx, dy);
                    if (dir) {
                        setDpadFeedback(dir);
                        dpadDoMove(dir);
                        dpadOriginX = e.clientX;
                        dpadOriginY = e.clientY;
                        if (dir !== dpadHoldDir) startHoldRepeat(dir);
                        dpadLastDir = dir;
                    }
                });
                const endMouse = () => {
                    if (mouseDown) {
                        mouseDown = false;
                        clearDpadState();
                    }
                };
                dpadOverlay.addEventListener('mouseup', endMouse);
                dpadOverlay.addEventListener('mouseleave', endMouse);

                // Global cleanup
                window.addEventListener('blur', clearDpadState);
            }

            // B Button - destroy hazard
            const btnB = document.getElementById('btn-b');
            if (btnB) {
                const handleB = createTouchHandler(() => {
                    if (!state.audioCtx) initAudio();
                    hapticFeedback('medium');
                    destroyHazard();
                }, { addPressedClass: true, element: btnB });

                if (supportsPointerEvents) {
                    btnB.addEventListener('pointerdown', handleB);
                } else {
                    btnB.addEventListener('touchstart', handleB, { passive: false });
                }
                btnB.addEventListener('click', handleB);
            }

            // A Button - reveal pulse
            const btnA = document.getElementById('btn-a');
            if (btnA) {
                const handleA = createTouchHandler(() => {
                    if (!state.audioCtx) initAudio();
                    hapticFeedback('medium');
                    activateRevealPulse();
                }, { addPressedClass: true, element: btnA });

                if (supportsPointerEvents) {
                    btnA.addEventListener('pointerdown', handleA);
                } else {
                    btnA.addEventListener('touchstart', handleA, { passive: false });
                }
                btnA.addEventListener('click', handleA);
            }

            // SELECT button - pause
            const selectBtn = document.getElementById('select-btn');
            if (selectBtn) {
                const handleSelect = createTouchHandler(() => {
                    if (!state.audioCtx) initAudio();
                    hapticFeedback('medium');
                    togglePause();
                }, { addPressedClass: true, element: selectBtn });

                if (supportsPointerEvents) {
                    selectBtn.addEventListener('pointerdown', handleSelect);
                } else {
                    selectBtn.addEventListener('touchstart', handleSelect, { passive: false });
                }
                selectBtn.addEventListener('click', handleSelect);
            }

            // START button - start game or unpause
            const startGameBtn = document.getElementById('start-game-btn');
            if (startGameBtn) {
                const handleStart = createTouchHandler(() => {
                    if (!state.audioCtx) initAudio();
                    hapticFeedback('medium');
                    if (state.gamePaused) {
                        togglePause();
                    } else if (!state.gameStarted && !document.getElementById('menu-screen').classList.contains('hidden')) {
                        startGame();
                    }
                }, { addPressedClass: true, element: startGameBtn });

                if (supportsPointerEvents) {
                    startGameBtn.addEventListener('pointerdown', handleStart);
                } else {
                    startGameBtn.addEventListener('touchstart', handleStart, { passive: false });
                }
                startGameBtn.addEventListener('click', handleStart);
            }
        }

        function togglePause() {
            if (state.gameStarted && !state.gameOver) {
                state.gamePaused = !state.gamePaused;
                hapticFeedback('medium');
                document.getElementById('pause-overlay').classList.toggle('hidden', !state.gamePaused);
                if (state.gamePaused) {
                    pauseBackgroundMusic();
                    releaseWakeLock(); // Release wake lock when paused
                    // D-pad swipe state is managed by its own clearDpadState
                } else {
                    resumeBackgroundMusic();
                    requestWakeLock(); // Request wake lock when unpaused
                }
            }
        }

        // ===== SETUP =====
        function calculateTileSize() {
            const isMobileFullscreen = window.innerWidth <= 640;
            // Use actual viewport height (accounts for iOS Safari address bar)
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;

            if (isMobileFullscreen) {
                // Mobile fullscreen - calculate based on available screen space
                const isLandscape = viewportWidth > viewportHeight;

                // Get safe area insets if available
                const safeAreaTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-top') || '0');
                const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-bottom') || '0');

                if (isLandscape) {
                    // Landscape: screen takes left portion, controls on right
                    const controlsWidth = Math.min(180, viewportWidth * 0.25);
                    const availableWidth = viewportWidth - controlsWidth - 24; // Padding
                    const availableHeight = viewportHeight - 24; // Minimal padding

                    const maxTileW = Math.floor(availableWidth / state.mazeWidth);
                    const maxTileH = Math.floor(availableHeight / state.mazeHeight);
                    return Math.min(Math.max(Math.min(maxTileW, maxTileH), 12), 28);
                } else {
                    // Portrait: screen on top, controls below
                    // Dynamically calculate controls height based on screen height
                    let controlsHeight, brandHeight, padding;

                    if (viewportHeight <= 600) {
                        // Very small screens (iPhone SE)
                        controlsHeight = 140;
                        brandHeight = 28;
                        padding = 40;
                    } else if (viewportHeight <= 700) {
                        // Small screens (iPhone mini)
                        controlsHeight = 160;
                        brandHeight = 32;
                        padding = 50;
                    } else if (viewportHeight <= 850) {
                        // Medium screens (iPhone, iPhone Pro)
                        controlsHeight = 175;
                        brandHeight = 36;
                        padding = 55;
                    } else {
                        // Large screens (iPhone Plus, Pro Max)
                        controlsHeight = 200;
                        brandHeight = 40;
                        padding = 60;
                    }

                    // Account for safe areas on notched phones
                    const safeAreaPadding = safeAreaTop + safeAreaBottom;

                    const availableHeight = viewportHeight - controlsHeight - brandHeight - padding - safeAreaPadding;
                    const availableWidth = viewportWidth - 32; // Side padding and bezel

                    const maxTileW = Math.floor(availableWidth / state.mazeWidth);
                    const maxTileH = Math.floor(availableHeight / state.mazeHeight);

                    // Allow larger tiles on bigger screens
                    const maxTileSize = viewportHeight > 800 ? 26 : (viewportHeight > 700 ? 24 : 22);
                    const minTileSize = viewportHeight < 600 ? 12 : 14;

                    return Math.min(Math.max(Math.min(maxTileW, maxTileH), minTileSize), maxTileSize);
                }
            } else {
                // Desktop - original calculation
                const deviceWidth = Math.min(viewportWidth - 16, 400);
                const screenWidth = deviceWidth - 70;
                const screenHeight = 240;

                const maxTileW = Math.floor(screenWidth / state.mazeWidth);
                const maxTileH = Math.floor(screenHeight / state.mazeHeight);
                return Math.min(Math.max(Math.min(maxTileW, maxTileH), 10), 20);
            }
        }

        let resizeTimeout;
        function resizeCanvas() {
            // Debounce resize for performance
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Update viewport height first
                setAppHeight();
                // Then recalculate tile size
                state.tileSize = calculateTileSize();
                state.canvas.width = state.mazeWidth * state.tileSize;
                state.canvas.height = state.mazeHeight * state.tileSize;
                if (state.gameStarted && !state.gamePaused && !state.gameOver) {
                    draw();
                }
            }, 100);
        }

        function setup() {
            // Ensure viewport height is set correctly for mobile
            setAppHeight();

            state.canvas = document.getElementById('game-canvas');
            state.ctx = state.canvas.getContext('2d');
            state.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            state.tileSize = calculateTileSize();
            state.canvas.width = state.mazeWidth * state.tileSize;
            state.canvas.height = state.mazeHeight * state.tileSize;

            // Handle resize and orientation change
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', () => {
                // Small delay to let the browser finish rotating
                setTimeout(resizeCanvas, 150);
                // Additional delayed resize to catch any late layout changes
                setTimeout(resizeCanvas, 500);
            });

            // Load leaderboard and stats
            loadLeaderboard();
            loadStats();

            // Load saved preferences
            state.sfxEnabled = localStorage.getItem('mazeSfxEnabled') !== 'false';
            state.musicEnabled = localStorage.getItem('mazeMusicEnabled') !== 'false';

            document.getElementById('high-score').textContent = state.highScore;
            document.getElementById('sfx-text').textContent = state.sfxEnabled ? 'ON' : 'OFF';
            document.getElementById('music-text').textContent = state.musicEnabled ? 'ON' : 'OFF';

            // Initialize background music
            initBackgroundMusic();
            renderCharacterSelectionLogos();

            // Name entry screen
            const nameInput = document.getElementById('player-name-input');
            const startBtn = document.getElementById('start-btn');

            // Check if player name is saved
            const savedName = localStorage.getItem('mazePlayerName');
            if (savedName) {
                nameInput.value = sanitizePlayerName(savedName, 'Player');
            }

            // Track touch time for name screen START button
            let nameStartTouchTime = 0;

            const handleStart = () => {
                const name = sanitizePlayerName(nameInput.value, 'Player');
                nameInput.value = name;
                state.playerName = name;
                localStorage.setItem('mazePlayerName', name);
                document.getElementById('player-name-display').textContent = name;
                document.getElementById('name-screen').classList.add('hidden');
                document.getElementById('menu-screen').classList.remove('hidden');
                if (!state.audioCtx) initAudio();
                hapticFeedback('medium');
            };

            // Touch-aware handler for START button on name screen
            const handleStartEvent = (e) => {
                const now = Date.now();
                const isTouch = e.type === 'touchstart';

                // Prevent double-firing
                if (!isTouch && (now - nameStartTouchTime) < 300) {
                    e.preventDefault();
                    return;
                }

                if (isTouch) {
                    nameStartTouchTime = now;
                    e.preventDefault();
                }

                // Visual feedback
                startBtn.classList.add('pressed');
                setTimeout(() => startBtn.classList.remove('pressed'), 150);

                handleStart();
            };

            startBtn.addEventListener('touchstart', handleStartEvent, { passive: false });
            startBtn.addEventListener('click', handleStartEvent);

            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleStart();
                }
            });

            // Shared touch timestamp for screen buttons (separate from game controls)
            let screenButtonTouchTime = 0;
            const SCREEN_BUTTON_DEBOUNCE = 300; // ms

            // Helper to add both click and touch handlers for screen buttons
            function addTapHandler(element, handler) {
                if (!element) return;

                const handleEvent = (e) => {
                    const now = Date.now();
                    const isTouch = e.type === 'touchstart';

                    // Prevent double-firing: ignore click if it follows touch too quickly
                    if (!isTouch && (now - screenButtonTouchTime) < SCREEN_BUTTON_DEBOUNCE) {
                        e.preventDefault();
                        return;
                    }

                    if (isTouch) {
                        screenButtonTouchTime = now;
                        e.preventDefault();
                    }

                    // Visual feedback
                    element.classList.add('pressed');
                    setTimeout(() => element.classList.remove('pressed'), 150);

                    hapticFeedback('light');
                    handler();
                };

                element.addEventListener('touchstart', handleEvent, { passive: false });
                element.addEventListener('click', handleEvent);
            }

            // Music toggle button
            addTapHandler(document.getElementById('music-toggle'), () => {
                if (!state.musicStarted) startBackgroundMusic();
                toggleBackgroundMusic();
            });

            // Leaderboard buttons
            addTapHandler(document.getElementById('leaderboard-btn'), showLeaderboard);
            addTapHandler(document.getElementById('gameover-leaderboard-btn'), showLeaderboard);
            addTapHandler(document.getElementById('close-leaderboard-btn'), hideLeaderboard);

            // SFX toggle
            addTapHandler(document.getElementById('sfx-toggle'), toggleSFX);

            // Stats buttons
            addTapHandler(document.getElementById('stats-btn'), showStats);
            addTapHandler(document.getElementById('close-stats-btn'), hideStats);

            // Difficulty selection
            document.querySelectorAll('.diff-btn').forEach(btn => {
                addTapHandler(btn, () => {
                    if (!state.audioCtx) initAudio();
                    playTone(500, 0.05, 'square', 0.02);
                    state.difficulty = btn.dataset.diff;
                    document.querySelectorAll('.diff-btn').forEach(b => {
                        b.style.background = '#8bac0f';
                        b.style.color = '#0f380f';
                    });
                    btn.style.background = '#306230';
                    btn.style.color = '#9bbc0f';
                });
            });

            // Character selection (using symbol mapping)
            document.querySelectorAll('#characters button').forEach(btn => {
                addTapHandler(btn, () => {
                    if (!state.audioCtx) initAudio();
                    playTone(600, 0.05, 'square', 0.02);
                    const charKey = btn.dataset.char;
                    state.character = state.characterMap[charKey] || '@';
                    document.querySelectorAll('#characters button').forEach(b => {
                        b.style.background = '#8bac0f';
                    });
                    btn.style.background = '#306230';
                });
            });

            // Play button
            addTapHandler(document.getElementById('play-btn'), () => {
                if (isTutorialNeeded()) {
                    startTutorial();
                } else {
                    startGame();
                }
            });

            // Tutorial skip button
            addTapHandler(document.getElementById('tutorial-skip-btn'), skipTutorial);

            // Game over buttons
            addTapHandler(document.getElementById('play-again-btn'), startGame);
            addTapHandler(document.getElementById('menu-btn'), () => {
                document.getElementById('game-over').classList.add('hidden');
                document.getElementById('game-screen').classList.add('hidden');
                document.getElementById('menu-screen').classList.remove('hidden');
                document.getElementById('high-score').textContent = state.highScore;
            });

            // Pause buttons
            addTapHandler(document.getElementById('resume-btn'), () => {
                state.gamePaused = false;
                document.getElementById('pause-overlay').classList.add('hidden');
                resumeBackgroundMusic();
                requestWakeLock();
            });
            addTapHandler(document.getElementById('quit-btn'), () => {
                // Save score and stats before quitting
                saveStats();
                if (state.score > 0) {
                    addToLeaderboard(state.playerName, state.score, state.level);
                }
                state.gamePaused = false;
                state.gameStarted = false;
                document.getElementById('pause-overlay').classList.add('hidden');
                document.getElementById('game-screen').classList.add('hidden');
                document.getElementById('menu-screen').classList.remove('hidden');
                // Music keeps playing in menu
                resumeBackgroundMusic();
            });
            
            setupInput();
            requestAnimationFrame(gameLoop);
        }

        // Start
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setup);
        } else {
            setup();
        }
    </script>
</body>
</html>
